#!/usr/bin/env bash
set -euo pipefail

# Configuration
DEFAULT_FLAGS=()
# readonly IMAGE_NAME="claudebox"  # Now computed per project
readonly DOCKER_USER="claude"
readonly USER_ID=$(id -u)
readonly GROUP_ID=$(id -g)
readonly PROJECT_DIR="$(pwd)"

# ────────────────────────────────────────────────────────────────────────────────
#  Cross-platform host detection (Linux vs. macOS) and FS case-sensitivity check
# ────────────────────────────────────────────────────────────────────────────────
OS_TYPE="$(uname -s)"
case "$OS_TYPE" in
  Darwin*) HOST_OS="macOS" ;;
  Linux*)  HOST_OS="linux" ;;
  *) echo "Unsupported operating system: $OS_TYPE" >&2; exit 1 ;;
esac

# Detect case‑insensitive default macOS filesystems (HFS+/APFS)
# Exit code 0  → case‑sensitive, 1 → case‑insensitive
is_case_sensitive_fs() {
  local t1 t2
  t1="$(mktemp "/tmp/.fs_case_test.XXXXXXXX")"
  # More portable uppercase conversion
  t2="$(echo "$t1" | tr '[:lower:]' '[:upper:]')"
  touch "$t1"
  [[ -e "$t2" && "$t1" != "$t2" ]] && { rm -f "$t1"; return 1; }
  rm -f "$t1"
  return 0
}

# Normalise docker‑build contexts on case‑insensitive hosts to avoid collisions
if [[ "$HOST_OS" == "macOS" ]] && ! is_case_sensitive_fs; then
  export COMPOSE_DOCKER_CLI_BUILD=1   # new BuildKit path‑normaliser
  export DOCKER_BUILDKIT=1
fi


# Cross-platform script path resolution
get_script_path() {
    local source="${BASH_SOURCE[0]:-$0}"
    while [[ -L "$source" ]]; do
        local dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ $source != /* ]] && source="$dir/$source"
    done
    echo "$(cd -P "$(dirname "$source")" && pwd)/$(basename "$source")"
}
readonly SCRIPT_PATH="$(get_script_path)"

readonly LINK_TARGET="$HOME/.local/bin/claudebox"
readonly NODE_VERSION="--lts"
readonly DELTA_VERSION="0.17.0"

# Color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m'

# Utility functions
cecho() { echo -e "${2:-$NC}$1${NC}"; }
error() { cecho "$1" "$RED" >&2; exit "${2:-1}"; }
warn() { cecho "$1" "$YELLOW"; }
info() { cecho "$1" "$BLUE"; }
success() { cecho "$1" "$GREEN"; }

# Parse early flags
VERBOSE=false

for arg in "$@"; do   # SC2068 is fine – we want word–splitting on purpose here
    case "$arg" in
        --verbose) VERBOSE=true ; shift ;;
    esac
done

# Load saved default flags if they exist
if [[ -f "$HOME/.claudebox/default-flags" ]]; then
    while IFS= read -r flag; do
        [[ -n "$flag" ]] && DEFAULT_FLAGS+=("$flag")
    done < "$HOME/.claudebox/default-flags"
fi

# Logo
logo() {
    local cb='
 ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
██║     ██║     ███████║██║   ██║██║  ██║█████╗
██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝
╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
 ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝

██████╗  ██████╗ ██╗  ██╗ ------ ┌──────────────┐
██╔══██╗██╔═══██╗╚██╗██╔╝ ------ │ The Ultimate │
██████╔╝██║   ██║ ╚███╔╝  ------ │ Claude Code  │
██╔══██╗██║   ██║ ██╔██╗  ------ │  Docker Dev  │
██████╔╝╚██████╔╝██╔╝ ██╗ ------ │ Environment  │
╚═════╝  ╚═════╝ ╚═╝  ╚═╝ ------ └──────────────┘
'
    while IFS= read -r l; do
        o="" c=""
        for ((i=0;i<${#l};i++)); do
            ch="${l:$i:1}"
            [[ "$ch" == " " ]] && { o+="$ch"; continue; }
            cc=$(printf '%d' "'$ch" 2>/dev/null||echo 0)
            if [[ $cc -ge 32 && $cc -le 126 ]]; then n='\033[33m'
            elif [[ $cc -ge 9552 && $cc -le 9580 ]]; then n='\033[34m'
            elif [[ $cc -eq 9608 ]]; then n='\033[31m'
            else n='\033[37m'; fi
            [[ "$n" != "$c" ]] && { o+="$n"; c="$n"; }
            o+="$ch"
        done
        echo -e "${o}\033[0m"
    done <<< "$cb"
}

update_symlink() {
    # Skip symlink management if claudebox is already in PATH as a real file
    if command -v claudebox >/dev/null 2>&1; then
        local found_path=$(which claudebox 2>/dev/null)
        if [[ -f "$found_path" ]] && [[ ! -L "$found_path" ]]; then
            [[ "$VERBOSE" == "true" ]] && info "Claudebox already installed at $found_path"
            return 0
        fi
    fi
    
    # Ensure the directory exists
    mkdir -p "$(dirname "$LINK_TARGET")"

    # Check if symlink exists and points to the correct location
    if [[ -L "$LINK_TARGET" ]]; then
        local current_target
        current_target=$(readlink "$LINK_TARGET" 2>/dev/null || echo "")
        if [[ "$current_target" == "$SCRIPT_PATH" ]]; then
            [[ "$VERBOSE" == "true" ]] && info "Symlink already correct: $LINK_TARGET → $SCRIPT_PATH"
            return 0
        else
            # Remove incorrect symlink
            rm -f "$LINK_TARGET"
            [[ "$VERBOSE" == "true" ]] && info "Removing outdated symlink"
        fi
    elif [[ -e "$LINK_TARGET" ]]; then
        # Check if it's the actual claudebox script
        if [[ -f "$LINK_TARGET" ]] && [[ -x "$LINK_TARGET" ]]; then
            # It's an executable file, likely the converted claudebox
            [[ "$VERBOSE" == "true" ]] && info "Found claudebox executable at $LINK_TARGET (not a symlink)"
            return 0
        else
            # Something else exists at this path
            error "Cannot create symlink: $LINK_TARGET already exists and is not a symlink"
        fi
    fi

    # Create new symlink
    if ln -s "$SCRIPT_PATH" "$LINK_TARGET"; then
        success "Symlink updated: $LINK_TARGET → $SCRIPT_PATH"
    else
        warn "Could not create symlink at $LINK_TARGET"
        warn "Try running with sudo or ensure $(dirname "$LINK_TARGET") is writable"
        warn "Error: $?"
    fi
}

# Docker checks
check_docker() {
    command -v docker &>/dev/null || return 1
    docker info &>/dev/null || return 2
    docker ps &>/dev/null || return 3
    return 0
}

install_docker() {
    warn "Docker is not installed."
    cecho "Would you like to install Docker now? (y/n)" "$CYAN"
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || error "Docker is required. Visit: https://docs.docker.com/engine/install/"

    info "Installing Docker..."

    [[ -f /etc/os-release ]] && . /etc/os-release || error "Cannot detect OS"

    case "${ID:-}" in
        ubuntu|debian)
            warn "Installing Docker requires sudo privileges..."
            sudo apt-get update
            sudo apt-get install -y ca-certificates curl gnupg lsb-release
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL "https://download.docker.com/linux/$ID/gpg" | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$ID $(lsb_release -cs) stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            ;;
        fedora|rhel|centos)
            warn "Installing Docker requires sudo privileges..."
            sudo dnf -y install dnf-plugins-core
            sudo dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
            sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            sudo systemctl start docker
            sudo systemctl enable docker
            ;;
        arch|manjaro)
            warn "Installing Docker requires sudo privileges..."
            sudo pacman -S --noconfirm docker
            sudo systemctl start docker
            sudo systemctl enable docker
            ;;
        *)
            error "Unsupported OS: ${ID:-unknown}. Visit: https://docs.docker.com/engine/install/"
            ;;
    esac

    success "Docker installed successfully!"
    configure_docker_nonroot
}

configure_docker_nonroot() {
    warn "Configuring Docker for non-root usage..."
    warn "This requires sudo to add you to the docker group..."

    getent group docker >/dev/null || sudo groupadd docker
    sudo usermod -aG docker "$USER"

    success "Docker configured for non-root usage!"
    warn "You need to log out and back in for group changes to take effect."
    warn "Or run: ${CYAN}newgrp docker"
    warn "Then run 'claudebox' again."
    info "Trying to activate docker group in current shell..."
    exec newgrp docker
}

# Spinner
show_spinner() {
    local pid=$1 msg=$2 spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏' i=0
    echo -n "$msg "
    while kill -0 "$pid" 2>/dev/null; do
        printf "\b%s" "${spin:i++%${#spin}:1}"
        sleep 0.1
    done
    echo -e "\b${GREEN}✓${NC}"
}

# Bash 3.2 compatible profile functions (no associative arrays)
get_profile_packages() {
    case "$1" in
        core) echo "gcc g++ make git pkg-config libssl-dev libffi-dev zlib1g-dev tmux" ;;
        build-tools) echo "cmake ninja-build autoconf automake libtool" ;;
        shell) echo "rsync openssh-client man-db gnupg2 aggregate file" ;;
        networking) echo "iptables ipset iproute2 dnsutils" ;;
        c) echo "gdb valgrind clang clang-format clang-tidy cppcheck doxygen libboost-all-dev libcmocka-dev libcmocka0 lcov libncurses5-dev libncursesw5-dev" ;;
        openwrt) echo "rsync libncurses5-dev zlib1g-dev gawk gettext xsltproc libelf-dev ccache subversion swig time qemu-system-arm qemu-system-aarch64 qemu-system-mips qemu-system-x86 qemu-utils" ;;
        rust) echo "" ;;  # Rust installed via rustup
        python) echo "" ;;  # Managed via uv
        go) echo "" ;;  # Installed from tarball
        javascript) echo "" ;;  # Installed via nvm
        java) echo "openjdk-17-jdk maven gradle ant" ;;
        ruby) echo "ruby-full ruby-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev software-properties-common" ;;
        php) echo "php php-cli php-fpm php-mysql php-pgsql php-sqlite3 php-curl php-gd php-mbstring php-xml php-zip composer" ;;
        database) echo "postgresql-client mysql-client sqlite3 redis-tools mongodb-clients" ;;
        devops) echo "docker.io docker-compose kubectl helm terraform ansible awscli" ;;
        web) echo "nginx apache2-utils httpie" ;;
        embedded) echo "gcc-arm-none-eabi gdb-multiarch openocd picocom minicom screen platformio" ;;
        datascience) echo "r-base" ;;
        security) echo "nmap tcpdump wireshark-common netcat-openbsd john hashcat hydra" ;;
        ml) echo "" ;;  # Just cmake needed, comes from build-tools now
        *) echo "" ;;
    esac
}

get_profile_description() {
    case "$1" in
        core) echo "Core Development Utilities (compilers, VCS, shell tools)" ;;
        build-tools) echo "Build Tools (CMake, autotools, Ninja)" ;;
        shell) echo "Optional Shell Tools (fzf, SSH, man, rsync, file)" ;;
        networking) echo "Network Tools (IP stack, DNS, route tools)" ;;
        c) echo "C/C++ Development (debuggers, analyzers, Boost, ncurses, cmocka)" ;;
        openwrt) echo "OpenWRT Development (cross toolchain, QEMU, distro tools)" ;;
        rust) echo "Rust Development (installed via rustup)" ;;
        python) echo "Python Development (managed via uv)" ;;
        go) echo "Go Development (installed from upstream archive)" ;;
        javascript) echo "JavaScript/TypeScript (Node installed via nvm)" ;;
        java) echo "Java Development (OpenJDK 17, Maven, Gradle, Ant)" ;;
        ruby) echo "Ruby Development (gems, native deps, XML/YAML)" ;;
        php) echo "PHP Development (PHP + extensions + Composer)" ;;
        database) echo "Database Tools (clients for major databases)" ;;
        devops) echo "DevOps Tools (Docker, Kubernetes, Terraform, etc.)" ;;
        web) echo "Web Dev Tools (nginx, HTTP test clients)" ;;
        embedded) echo "Embedded Dev (ARM toolchain, serial debuggers)" ;;
        datascience) echo "Data Science (Python, Jupyter, R)" ;;
        security) echo "Security Tools (scanners, crackers, packet tools)" ;;
        ml) echo "Machine Learning (build layer only; Python via uv)" ;;
        *) echo "" ;;
    esac
}

get_all_profile_names() {
    echo "core build-tools shell networking c openwrt rust python go javascript java ruby php database devops web embedded datascience security ml"
}

profile_exists() {
    local profile="$1"
    for p in $(get_all_profile_names); do
        [[ "$p" == "$profile" ]] && return 0
    done
    return 1
}

expand_profile() {
    case "$1" in
        c) echo "core build-tools c" ;;
        openwrt) echo "core build-tools openwrt" ;;
        ml) echo "core build-tools ml" ;;
        rust|go|python|php|ruby|java|database|devops|web|embedded|datascience|security|javascript)
            echo "core $1"
            ;;
        shell|networking|build-tools|core)
            echo "$1"
            ;;
        *)
            echo "$1"
            ;;
    esac
}

docker_exec_root() {
    docker exec -u root "$@"
}

docker_exec_user() {
    docker exec -u "$DOCKER_USER" "$@"
}

# Standardized container run function - ensures consistent mounts and environment
run_claudebox_container() {
    local container_name="$1"
    local run_mode="$2"  # "interactive", "detached", "pipe", or "attached"
    shift 2
    local container_args=("$@")
    
    # Handle "attached" mode - start detached, wait, then attach
    if [[ "$run_mode" == "attached" ]]; then
        # Start detached
        run_claudebox_container "$container_name" "detached" "${container_args[@]}" >/dev/null
        
        # Show progress while container initializes
        fillbar
        
        # Wait for container to be ready
        while ! docker exec "$container_name" true 2>/dev/null; do
            sleep 0.1
        done
        
        fillbar stop
        
        # Attach to ready container
        docker attach "$container_name"
        
        return
    fi
    
    local docker_args=()
    
    # Set run mode
    case "$run_mode" in
        "interactive")
            # Only use -it if we have a TTY
            if [ -t 0 ] && [ -t 1 ]; then
                docker_args+=("-it")
            fi
            # Only add --rm if no container name (for persistence)
            if [[ -z "$container_name" ]]; then
                docker_args+=("--rm")
            else
                docker_args+=("--name" "$container_name")
            fi
            docker_args+=("--init")
            ;;
        "detached")
            docker_args+=("-d")
            if [[ -n "$container_name" ]]; then
                docker_args+=("--name" "$container_name")
            fi
            ;;
        "pipe")
            docker_args+=("--rm" "--init")
            ;;
    esac
    
    # Add network mode if specified
    if [[ "${CLAUDEBOX_HOST_MODE:-false}" == "true" ]]; then
        docker_args+=("--network" "host")
    fi
    
    # Standard configuration for ALL containers
    docker_args+=(
        -w /workspace
        -v "$PROJECT_DIR":/workspace
        -v "$PROJECT_CLAUDEBOX_DIR/.claude":/home/$DOCKER_USER/.claude
        -v "$PROJECT_CLAUDEBOX_DIR/.claude.json":/home/$DOCKER_USER/.claude.json
        -v "$PROJECT_CLAUDEBOX_DIR/.config":/home/$DOCKER_USER/.config
        -v "$PROJECT_CLAUDEBOX_DIR/.cache":/home/$DOCKER_USER/.cache
        -v "$HOME/.ssh":"/home/$DOCKER_USER/.ssh:ro"
        -e "NODE_ENV=${NODE_ENV:-production}"
        -e "ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}"
        -e "CLAUDEBOX_PROJECT_NAME=$project_folder_name"
        -e "TERM=${TERM:-xterm-256color}"
        --cap-add NET_ADMIN
        --cap-add NET_RAW
        "$IMAGE_NAME"
    )
    
    # Add any additional arguments
    if [[ ${#container_args[@]} -gt 0 ]]; then
        docker_args+=("${container_args[@]}")
    fi
    
    docker run "${docker_args[@]}"
}

check_container_exists() {
    local container_name="$1"
    
    # Check if container exists (running or stopped)
    if docker ps -a --filter "name=^${container_name}$" --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
        # Check if it's running
        if docker ps --filter "name=^${container_name}$" --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
            echo "running"
        else
            echo "stopped"
        fi
    else
        echo "none"
    fi
}

FILLBAR_PID=""

fillbar() {
    case "${1:-}" in
        stop)
            if [ ! -z "$FILLBAR_PID" ]; then
                kill $FILLBAR_PID 2>/dev/null
            fi
            printf "\r\033[K"
            tput cnorm
            FILLBAR_PID=""
            ;;
        *)
            (
                p=0
                tput civis
                while true; do
                    printf "\r"
                    full=$((p / 8))
                    part=$((p % 8))
                    i=0
                    while [ $i -lt $full ]; do
                        printf "█"
                        i=$((i + 1))
                    done
                    if [ $part -gt 0 ]; then
                        pb=$(printf %x $((0x258F - part + 1)))
                        printf "\\u$pb"
                    fi
                    p=$((p + 1))
                    sleep 0.01
                done
            ) &
            FILLBAR_PID=$!
            ;;
    esac
}

show_help() {
    if docker image inspect "$IMAGE_NAME" &>/dev/null; then
        run_claudebox_container "" "pipe" --help | sed '1s/claude/claudebox/g'
        echo
        cecho "Added Options:" "$WHITE"
        echo -e "${CYAN}  --verbose                       ${WHITE}Show detailed output"
        echo -e "${CYAN}  --enable-sudo                   ${WHITE}Enable sudo without password"
        echo -e "${CYAN}  --disable-firewall              ${WHITE}Disable network restrictions"
        echo
        cecho "Added Commands:" "$WHITE"
        echo -e "  profiles                        List all available profiles"
        echo -e "  projects                        List all projects with paths"
        echo -e "  profile                         Profile management menu"
        echo -e "  install <packages>              Install apt packages"
        echo -e "  save [flags...]                 Save default flags (no args = clear saved flags)"
        echo -e "  shell                           Open transient shell (changes NOT saved)"
        echo -e "  shell admin                     Open admin shell (sudo, no firewall, changes saved)"
        echo -e "  allowlist                       Show/edit firewall allowlist"
        echo -e "  info                            Show comprehensive project info"
        echo -e "  clean                           Menu of cleanup tasks"
        echo -e "  unlink                          Remove claudebox symlink"
        echo -e "  rebuild                         Rebuild the Docker image from scratch${NC}"
    else
        cecho "ClaudeBox - Claude Code Docker Environment" "$CYAN"
        echo
        warn "First run setup required!"
        echo "Run script without arguments first to build the Docker image."
    fi
}

show_welcome_menu() {
    logo
    echo
    cecho "Welcome to ClaudeBox!" "$CYAN"
    echo
    cecho "Current directory:" "$WHITE"
    echo "  $PROJECT_DIR"
    echo
    
    # Check if workspace is set
    local workspace_file="$HOME/.claudebox/workpath"
    if [[ -f "$workspace_file" ]]; then
        local workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
        if [[ -n "$workspace" ]]; then
            cecho "Workspace:" "$WHITE"
            echo "  $workspace"
            echo
        fi
    fi
    
    cecho "Getting Started:" "$GREEN"
    echo -e "  ${YELLOW}claudebox init${NC}                  Initialize this folder as a project"
    echo -e "  ${YELLOW}claudebox init /path/to/folder${NC}  Initialize a specific folder"
    echo
    
    cecho "Project Management:" "$GREEN"
    echo -e "  ${YELLOW}claudebox projects${NC}              List all projects"
    echo -e "  ${YELLOW}claudebox project <name>${NC}       Show project details"
    echo -e "  ${YELLOW}claudebox <hash>${NC}               Launch project by hash"
    echo -e "  ${YELLOW}claudebox /path/to/project${NC}     Launch project by path"
    echo
    
    cecho "Other Commands:" "$GREEN"
    echo -e "  ${YELLOW}claudebox profiles${NC}              List available profiles"
    echo -e "  ${YELLOW}claudebox help${NC}                  Show detailed help"
    echo -e "  ${YELLOW}claudebox info${NC}                  Show system information"
    echo
    
    cecho "Quick Tips:" "$PURPLE"
    echo "  • Run 'claudebox init' to start working on a project"
    echo "  • Pre-authenticate multiple sessions for concurrent use"
    echo "  • Use workspace-relative paths for convenience"
    echo
}

show_project_status() {
    local status="$1"  # "not_initialized" or "no_slots"
    local project_path="${2:-$PROJECT_DIR}"
    
    # Get folder name
    local folder_name=$(basename "$project_path")
    
    # Count slots if initialized
    local slots_used=0
    local slots_total=0
    
    if [[ "$status" == "no_slots" ]]; then
        # Get the base folder name
        local clean_name
        clean_name=$(echo "$project_path" | tr '[:upper:]' '[:lower:]')
        clean_name="${clean_name//\//_}"
        clean_name="${clean_name#_}"
        
        # Count total slots and used slots
        for project_dir in "$HOME/.claudebox/projects/${clean_name}_"*/ ; do
            [[ -d "$project_dir" ]] || continue
            slots_total=$((slots_total + 1))
            
            local lock_file="$project_dir/.lock"
            if [[ -f "$lock_file" ]]; then
                local pid=$(cat "$lock_file" 2>/dev/null || echo "")
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    slots_used=$((slots_used + 1))
                fi
            fi
        done
    fi
    
    # Display status
    echo
    cecho "╔════════════════════════════════════════════════════════════════════╗" "$CYAN"
    cecho "║                        ClaudeBox Status                            ║" "$CYAN"
    cecho "╚════════════════════════════════════════════════════════════════════╝" "$CYAN"
    echo
    
    printf "  %-20s %-30s\n" "Project Dir:" "$project_path"
    printf "  %-20s " "Status:"
    if [[ "$status" == "not_initialized" ]]; then
        cecho "Not Initialized" "$YELLOW"
    else
        cecho "All slots in use" "$RED"
    fi
    printf "  %-20s %-30s\n" "Current Folder:" "$folder_name"
    printf "  %-20s %-30s\n" "Slots Used/Total:" "${slots_used}/${slots_total}"
    echo
    
    cecho "Available Commands:" "$GREEN"
    if [[ "$status" == "not_initialized" ]]; then
        echo -e "  ${YELLOW}claudebox init${NC}                  Initialize this folder"
        echo -e "  ${YELLOW}claudebox init /path/to/folder${NC}  Initialize a different folder"
    else
        echo -e "  ${YELLOW}claudebox init${NC}                  Create another slot for this project"
    fi
    echo -e "  ${YELLOW}claudebox projects${NC}              List all projects"
    echo -e "  ${YELLOW}claudebox project <name>${NC}       Show project details"
    echo -e "  ${YELLOW}claudebox profiles${NC}              List available profiles"
    echo -e "  ${YELLOW}claudebox info${NC}                  Show system information"
    echo
}

fnv1a_32() {
    local input_str="${1:-}"
    local hash_val=2166136261
    local fnv_prime=16777619
    local mask_32bit=4294967295

    for (( i=0; i<${#input_str}; i++ )); do
        local byte
        byte=$(printf '%d' "'${input_str:$i:1}")
        hash_val=$(( ((hash_val ^ byte) * fnv_prime) & mask_32bit ))
    done
    printf "0x%x\n" "$hash_val"
}


check_if_initialized() {
    local project_path="$1"
    local projects_dir="$HOME/.claudebox/projects"
    
    # Get the base folder name (without instance suffix)
    local clean_name
    clean_name=$(echo "$project_path" | tr '[:upper:]' '[:lower:]')
    clean_name="${clean_name//\//_}"
    clean_name="${clean_name#_}"
    
    # Check if any folder starting with this clean_name exists
    if ls "$projects_dir" 2>/dev/null | grep -q "^${clean_name}_"; then
        return 0  # Initialized
    else
        return 1  # Not initialized
    fi
}

get_project_folder_name() {
    local project_path="$1"
    local force_new="${2:-false}"
    if [ -z "$project_path" ]; then echo "error_invalid_path"; return 1; fi

    local projects_dir="$HOME/.claudebox/projects"
    mkdir -p "$projects_dir"

    # Get clean name for folder prefix
    local clean_name
    clean_name=$(echo "$project_path" | tr '[:upper:]' '[:lower:]')
    clean_name="${clean_name//\//_}"
    clean_name="${clean_name#_}"
    
    # First iteration always uses direct path hash
    local parent_hash
    parent_hash=$(fnv1a_32 "$project_path")
    local parent_hash_suffix="${parent_hash#0x}"
    local parent_folder="${clean_name}_${parent_hash_suffix}"
    local parent_dir="$projects_dir/$parent_folder"
    
    # Check if parent exists - if not and we're not initializing, return error
    if [[ ! -d "$parent_dir" ]] && [[ "$force_new" != "true" ]]; then
        return 1  # Caller will handle showing not initialized
    fi
    
    # Get max iterations from parent folder (or default to 1)
    local max_iterations=1
    local hashcount_file="$parent_dir/.hashcount"
    if [[ -f "$hashcount_file" ]]; then
        max_iterations=$(cat "$hashcount_file" 2>/dev/null || echo "1")
    fi
    
    # Start from parent and iterate through the chain
    local current_hash="$parent_hash_suffix"
    local iteration=1
    
    while [[ $iteration -le $max_iterations ]]; do
        local project_folder="${clean_name}_${current_hash}"
        local project_dir="$projects_dir/$project_folder"
        local lock_file="$project_dir/.lock"
        
        # For first iteration, ensure parent directory exists only if initializing
        if [[ $iteration -eq 1 ]] && [[ "$force_new" == "true" ]]; then
            mkdir -p "$project_dir"
        fi
        
        # If force_new is true, skip folders that already exist
        if [[ "$force_new" == "true" ]] && [[ -d "$project_dir" ]]; then
            # Move to next iteration
            current_hash=$(fnv1a_32 "$current_hash")
            current_hash="${current_hash#0x}"
            iteration=$((iteration + 1))
            continue
        fi
        
        # Only create directories if forcing new (init) or if slot already exists
        if [[ ! -d "$project_dir" ]]; then
            if [[ "$force_new" != "true" ]]; then
                # Not initializing and slot doesn't exist - skip it
                current_hash=$(fnv1a_32 "$current_hash")
                current_hash="${current_hash#0x}"
                iteration=$((iteration + 1))
                continue
            else
                # Initializing - create the directory
                mkdir -p "$project_dir"
            fi
        fi
        
        # Try to acquire lock
        if mkdir "${lock_file}.acquiring" 2>/dev/null; then
            if [ -f "$lock_file" ]; then
                local lock_pid
                lock_pid=$(cat "$lock_file" 2>/dev/null || echo "")
                
                if [ -n "$lock_pid" ] && kill -0 "$lock_pid" 2>/dev/null; then
                    # Slot is active, try next
                    rmdir "${lock_file}.acquiring"
                    current_hash=$(fnv1a_32 "$current_hash")
                    current_hash="${current_hash#0x}"
                    iteration=$((iteration + 1))
                    continue
                fi
            fi
            
            # Got the slot!
            echo $$ > "$lock_file"
            rmdir "${lock_file}.acquiring"
            
            # Update max iterations if we've extended beyond it
            if [[ $iteration -gt $max_iterations ]] && [[ "$force_new" == "true" ]]; then
                echo "$iteration" > "$hashcount_file"
            fi
            
            export CLAUDEBOX_LOCK_FILE="$lock_file"
            echo "$project_folder"
            return 0
        else
            sleep 0.1
        fi
    done
    
    # If we've exhausted all iterations and force_new, extend the chain
    if [[ "$force_new" == "true" ]]; then
        max_iterations=$((max_iterations + 1))
        current_hash=$(fnv1a_32 "$current_hash")
        current_hash="${current_hash#0x}"
        local project_folder="${clean_name}_${current_hash}"
        local project_dir="$projects_dir/$project_folder"
        mkdir -p "$project_dir"
        
        echo "$max_iterations" > "$hashcount_file"
        echo $$ > "$project_dir/.lock"
        export CLAUDEBOX_LOCK_FILE="$project_dir/.lock"
        echo "$project_folder"
        return 0
    fi
    
    # No available slots found - show status instead of error
    show_project_status "no_slots" "$project_path"
    exit 1
}

get_profile_file_path() {
    # Don't call get_project_folder_name here - use the already set project_folder_name
    local project_dir="$HOME/.claudebox/projects/$project_folder_name"
    mkdir -p "$project_dir"
    echo "$project_dir/config.ini"
}

read_config_value() {
    local config_file="$1"
    local section="$2"
    local key="$3"

    [[ -f "$config_file" ]] || return 1

    awk -F ' *= *' -v section="[$section]" -v key="$key" '
        $0 == section { in_section=1; next }
        /^\[/ { in_section=0 }
        in_section && $1 == key { print $2; exit }
    ' "$config_file"
}

get_project_by_path() {
    local search_path="$1"
    local abs_path=$(realpath "$search_path" 2>/dev/null || echo "$search_path")
    for project_dir in "$HOME/.claudebox/projects"/*/ ; do
        [[ -d "$project_dir" ]] || continue
        local config_file="$project_dir/config.ini"
        [[ -f "$config_file" ]] || continue
        local stored_path=$(read_config_value "$config_file" "project" "path")
        if [[ "$stored_path" == "$abs_path" ]]; then
            basename "$project_dir"
            return 0
        fi
    done
    return 1
}

list_all_projects_aggregated() {
    local projects_found=0
    local workspace_file="$HOME/.claudebox/workpath"
    local workspace=""
    
    if [[ -f "$workspace_file" ]]; then
        workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
    fi
    
    # Build associative data using functions for Bash 3.2 compatibility
    local paths=()
    local seen_paths=""
    
    # First pass - collect unique paths
    for project_dir in "$HOME/.claudebox/projects"/*/ ; do
        [[ -d "$project_dir" ]] || continue
        local config_file="$project_dir/config.ini"
        local path="(unknown)"
        
        if [[ -f "$config_file" ]]; then
            local path_value=$(read_config_value "$config_file" "project" "path")
            [[ -n "$path_value" ]] && path="$path_value"
        fi
        
        # Add to paths if not seen
        if [[ ! " $seen_paths " =~ " $path " ]]; then
            paths+=("$path")
            seen_paths="$seen_paths $path"
        fi
    done
    
    # Sort paths
    IFS=$'\n' paths=($(printf '%s\n' "${paths[@]}" | sort))
    
    # Second pass - aggregate data for each path
    for path in "${paths[@]}"; do
        local total_slots=0
        local active_instances=0
        local ready_slots=0
        local total_size=0
        local has_docker=false
        
        # Get all slots for this path
        for project_dir in "$HOME/.claudebox/projects"/*/ ; do
            [[ -d "$project_dir" ]] || continue
            local config_file="$project_dir/config.ini"
            local this_path="(unknown)"
            
            if [[ -f "$config_file" ]]; then
                local path_value=$(read_config_value "$config_file" "project" "path")
                [[ -n "$path_value" ]] && this_path="$path_value"
            fi
            
            if [[ "$this_path" == "$path" ]]; then
                total_slots=$((total_slots + 1))
                
                # Check if instance is active
                local lock_file="$project_dir/.lock"
                if [[ -f "$lock_file" ]]; then
                    local pid=$(cat "$lock_file" 2>/dev/null || echo "")
                    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                        active_instances=$((active_instances + 1))
                    else
                        # Lock file exists but process is dead - this is ready
                        ready_slots=$((ready_slots + 1))
                    fi
                else
                    # No lock file - check if authenticated
                    # For now, just count as ready if folder exists
                    ready_slots=$((ready_slots + 1))
                fi
                
                # Check Docker image
                local project_id=$(basename "$project_dir")
                local image_name="claudebox-${project_id}"
                if docker image inspect "$image_name" &>/dev/null; then
                    has_docker=true
                fi
            fi
        done
        
        # Format display path
        local display_path="$path"
        if [[ -n "$workspace" ]] && [[ "$path" == "$workspace"/* ]]; then
            display_path="${path#$workspace/}"
        fi
        
        # Docker status
        local docker_icon="❌"
        [[ "$has_docker" == "true" ]] && docker_icon="✅"
        
        # Size placeholder (could aggregate later)
        local size_str="-"
        
        # Status string: instances/ready/total
        local status="${active_instances}/${ready_slots}/${total_slots}"
        
        printf "%10s  %-11s  %s  %s\n" "$size_str" "$status" "$docker_icon" "$display_path"
        projects_found=1
    done
    
    [[ $projects_found -eq 0 ]] && return 1
    return 0
}

list_project_slots() {
    local project_path="$1"
    local found=0
    
    # Find all slots for this project
    for project_dir in "$HOME/.claudebox/projects"/*/ ; do
        [[ -d "$project_dir" ]] || continue
        local config_file="$project_dir/config.ini"
        local this_path="(unknown)"
        
        if [[ -f "$config_file" ]]; then
            local path_value=$(read_config_value "$config_file" "project" "path")
            [[ -n "$path_value" ]] && this_path="$path_value"
        fi
        
        if [[ "$this_path" == "$project_path" ]]; then
            found=1
            local project_id=$(basename "$project_dir")
            local hash="${project_id##*_}"
            local status_icon="❌"
            local status_text="Empty slot"
            
            # Check lock status
            local lock_file="$project_dir/.lock"
            if [[ -f "$lock_file" ]]; then
                local pid=$(cat "$lock_file" 2>/dev/null || echo "")
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    status_icon="🟢"
                    status_text="Instance (PID: $pid)"
                else
                    # Check if authenticated
                    status_icon="🔑"
                    status_text="Ready"
                fi
            else
                # Check if slot has data
                if [[ -d "$project_dir/.claude" ]]; then
                    status_icon="🔓"
                    status_text="Not authenticated"
                fi
            fi
            
            # Check if parent
            local parent_marker=""
            local hashcount_file="$project_dir/.hashcount"
            [[ -f "$hashcount_file" ]] && parent_marker=" (Parent)"
            
            printf "%s %s - %s%s\n" "$status_icon" "$hash" "$status_text" "$parent_marker"
        fi
    done
    
    [[ $found -eq 0 ]] && return 1
    return 0
}

list_all_projects() {
    local projects_found=0
    # shellcheck disable=SC2231 # We want pathname expansion even when no dirs
    for project_dir in "$HOME/.claudebox/projects"/*/ ; do
        [[ -d "$project_dir" ]] || continue
        projects_found=1
        local project_id=$(basename "$project_dir")
        local original_path="(unknown)"
        local process_status="🟥"
        local docker_status="❌"
        local image_size="-"
        
        # Get hash (last 8 chars of project_id after underscore)
        local hash="${project_id##*_}"
        if [[ ${#hash} -gt 8 ]]; then
            hash="${hash: -8}"
        fi
        
        # Check lock file for process status
        local lock_file="$project_dir/.lock"
        if [[ -f "$lock_file" ]]; then
            local pid=$(cat "$lock_file" 2>/dev/null || echo "")
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                process_status="🟩"
            fi
        fi
        
        local config_file="$project_dir/config.ini"
        if [[ -f "$config_file" ]]; then
            local path_value=$(read_config_value "$config_file" "project" "path")
            [[ -n "$path_value" ]] && original_path="$path_value"
        fi
        local image_name="claudebox-${project_id}"
        if docker image inspect "$image_name" &>/dev/null; then
            docker_status="✅"
            image_size=$(docker images --filter "reference=$image_name" --format "{{.Size}}")
        fi
        printf "%10s  %s  %s  %8s  %s\n" "$image_size" "$process_status" "$docker_status" "$hash" "$original_path"
    done
    [[ $projects_found -eq 0 ]] && return 1
    return 0
}

show_projects_list() {
    cecho "ClaudeBox Projects:" "$CYAN"
    
    # Show workspace if set
    local workspace_file="$HOME/.claudebox/workpath"
    if [[ -f "$workspace_file" ]]; then
        local workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
        if [[ -n "$workspace" ]]; then
            echo
            cecho "Workspace: $workspace" "$WHITE"
        fi
    fi
    
    echo
    printf "%10s  %-11s  %s  %s\n" "Size" "Slots (I/R/T)" "🐳" "Path"
    printf "%10s  %-11s  %s  %s\n" "----" "-------------" "--" "----"

    if ! list_all_projects_aggregated; then
        echo
        warn "No ClaudeBox projects found."
        echo
        cecho "Start a new project:" "$GREEN"
        echo "  cd /your/project/directory"
        echo "  claudebox init"
    fi
    echo
    cecho "I=Instances, R=Ready, T=Total" "$CYAN"
    echo
}

find_project_by_hash() {
    local hash="$1"
    local projects_dir="$HOME/.claudebox/projects"
    
    if [[ -d "$projects_dir" ]]; then
        for project_dir in "$projects_dir"/*; do
            [[ -d "$project_dir" ]] || continue
            local project_id=$(basename "$project_dir")
            
            # Check if project_id ends with the hash
            if [[ "$project_id" == *"_$hash" ]]; then
                echo "$project_id"
                return 0
            fi
        done
    fi
    
    return 1
}

resolve_project_path() {
    local input_path="${1:-$PWD}"

    # Check if input is a hash (8 hex chars)
    if [[ "$input_path" =~ ^[0-9a-fA-F]{8}$ ]]; then
        local project_id
        project_id=$(find_project_by_hash "$input_path")
        if [[ -n "$project_id" ]]; then
            echo "$project_id"
            return 0
        fi
    fi

    if [[ "$input_path" =~ _[a-f0-9]{6}$ ]] && [[ -d "$HOME/.claudebox/$input_path" ]]; then
        echo "$input_path"
        return 0
    fi

    local project_id=$(get_project_by_path "$input_path")
    if [[ -n "$project_id" ]]; then
        echo "$project_id"
        return 0
    fi

    return 1
}

read_profile_section() {
    local profile_file="$1"
    local section="$2"
    local result=()

    if [[ -f "$profile_file" ]] && grep -q "^\[$section\]" "$profile_file"; then
        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^\[.*\]$ ]] && break
            result+=("$line")
        done < <(sed -n "/^\[$section\]/,/^\[/p" "$profile_file" | tail -n +2 | grep -v '^\[')
    fi

    printf '%s\n' "${result[@]}"
}

update_profile_section() {
    local profile_file="$1"
    local section="$2"
    shift 2
    local new_items=("$@")

    local existing_items=()
    readarray -t existing_items < <(read_profile_section "$profile_file" "$section")

    local all_items=()
    for item in "${existing_items[@]}"; do
        [[ -n "$item" ]] && all_items+=("$item")
    done

    for item in "${new_items[@]}"; do
        local found=false
        for existing in "${all_items[@]}"; do
            [[ "$existing" == "$item" ]] && found=true && break
        done
        [[ "$found" == "false" ]] && all_items+=("$item")
    done

    {
        if [[ -f "$profile_file" ]]; then
            awk -v sect="$section" '
                BEGIN { in_section=0; skip_section=0 }
                /^\[/ {
                    if ($0 == "[" sect "]") { skip_section=1; in_section=1 }
                    else { skip_section=0; in_section=0 }
                }
                !skip_section { print }
                /^\[/ && !skip_section && in_section { in_section=0 }
            ' "$profile_file"
        fi

        echo "[$section]"
        for item in "${all_items[@]}"; do
            echo "$item"
        done
        echo ""
    } > "${profile_file}.tmp" && mv "${profile_file}.tmp" "$profile_file"
}

setup_project_folder() {
    mkdir -p "$PROJECT_CLAUDEBOX_DIR/.claude"
    mkdir -p "$PROJECT_CLAUDEBOX_DIR/.config"
    mkdir -p "$PROJECT_CLAUDEBOX_DIR/.cache"
    if [[ ! -f "$PROJECT_CLAUDEBOX_DIR/.claude.json" ]]; then
        echo '{}' > "$PROJECT_CLAUDEBOX_DIR/.claude.json"
    fi

    local config_file="$PROJECT_CLAUDEBOX_DIR/config.ini"
    if [[ ! -f "$config_file" ]]; then
        cat > "$config_file" <<EOF
[project]
path = $PROJECT_DIR

[profiles]

[packages]
EOF
    fi
}


# Ensure shared commands folder exists and is up to date
setup_shared_commands() {
    local shared_commands="$HOME/.claudebox/commands"
    local script_dir="$(dirname "$SCRIPT_PATH")"
    local commands_source="$script_dir/commands"
    
    # Create shared commands directory if it doesn't exist
    mkdir -p "$shared_commands"
    
    # Copy/update commands from script directory if it exists
    if [[ -d "$commands_source" ]]; then
        # Copy new or updated files (preserve existing user files)
        cp -n "$commands_source/"* "$shared_commands/" 2>/dev/null || true
        
        # For existing files, only update if source is newer
        for file in "$commands_source"/*; do
            if [[ -f "$file" ]]; then
                local basename=$(basename "$file")
                local dest_file="$shared_commands/$basename"
                if [[ -f "$dest_file" ]] && [[ "$file" -nt "$dest_file" ]]; then
                    cp "$file" "$dest_file"
                    if [[ "$VERBOSE" == "true" ]]; then
                        info "Updated command: $basename"
                    fi
                fi
            fi
        done
        
        if [[ "$VERBOSE" == "true" ]]; then
            info "Synchronized commands to shared folder: $shared_commands"
        fi
    fi
}

setup_claude_agent_command() {
    # Create commands symlink in project's .claude folder (mounts to ~/.claude in container)
    local shared_commands="$HOME/.claudebox/commands"
    local commands_dest="$PROJECT_CLAUDEBOX_DIR/.claude/commands"
    
    # Only create symlink if commands destination doesn't already exist
    if [[ ! -e "$commands_dest" ]]; then
        # Ensure parent directory exists
        mkdir -p "$PROJECT_CLAUDEBOX_DIR/.claude"
        
        # Create symlink to shared commands
        ln -s "$shared_commands" "$commands_dest"
        
        if [[ "$VERBOSE" == "true" ]]; then
            info "Linked shared commands to project"
        fi
    fi
}
create_build_files() {
    local build_context="$1"

    cat > "$build_context/init-firewall" << 'EOF'
#!/bin/bash
set -euo pipefail
if [ "${DISABLE_FIREWALL:-false}" = "true" ]; then
    echo "Firewall disabled, skipping setup"
    rm -f "$0"
    exit 0
fi
iptables -F OUTPUT 2>/dev/null || true
iptables -F INPUT 2>/dev/null || true
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
iptables -A INPUT -p udp --sport 53 -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -s 127.0.0.0/8 -d 127.0.0.0/8 -j ACCEPT
iptables -A INPUT -s 127.0.0.0/8 -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
# Default allowed domains
DEFAULT_DOMAINS="api.anthropic.com console.anthropic.com statsig.anthropic.com sentry.io"

ALLOWED_DOMAINS="$DEFAULT_DOMAINS"
ALLOWLIST_FILE="/home/DOCKERUSER/.claudebox/projects/${CLAUDEBOX_PROJECT_NAME:-}/allowlist"
if [ -f "$ALLOWLIST_FILE" ]; then
    while IFS= read -r line; do
        [[ "$line" =~ ^#.* ]] && continue
        [[ -z "$line" ]] && continue
        domain="${line#\*.}"
        domain="$(echo "$domain" | xargs)"
        [[ -n "$domain" ]] && ALLOWED_DOMAINS="$ALLOWED_DOMAINS $domain"
    done < "$ALLOWLIST_FILE"
fi

if command -v ipset >/dev/null 2>&1; then
    ipset destroy allowed-domains 2>/dev/null || true
    ipset create allowed-domains hash:net
    ipset destroy allowed-ips 2>/dev/null || true
    ipset create allowed-ips hash:net

    for domain in $ALLOWED_DOMAINS; do
        if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
            ipset add allowed-ips $domain 2>/dev/null || true
        else
            ips=$(getent hosts $domain 2>/dev/null | awk '{print $1}')
            for ip in $ips; do
                ipset add allowed-domains $ip 2>/dev/null || true
            done
        fi
    done
    iptables -A OUTPUT -m set --match-set allowed-domains dst -j ACCEPT
    iptables -A OUTPUT -m set --match-set allowed-ips dst -j ACCEPT
else
    for domain in $ALLOWED_DOMAINS; do
        if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
            iptables -A OUTPUT -d $domain -j ACCEPT
        else
            ips=$(getent hosts $domain 2>/dev/null | awk '{print $1}')
            for ip in $ips; do
                iptables -A OUTPUT -d $ip -j ACCEPT
            done
        fi
    done
fi
iptables -P OUTPUT DROP
iptables -P INPUT DROP
echo "Firewall initialized with Anthropic-only access"
rm -f "$(realpath "$0")"
EOF

    cat > "$build_context/docker-entrypoint.sh" << 'EOF'
#!/bin/bash
set -euo pipefail
ENABLE_SUDO=false
DISABLE_FIREWALL=false
SHELL_MODE=false
new_args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --enable-sudo) ENABLE_SUDO=true; shift ;;
        --disable-firewall) DISABLE_FIREWALL=true; shift ;;
        --shell-mode) SHELL_MODE=true; shift ;;
        *) new_args+=("$1"); shift ;;
    esac
done
set -- "${new_args[@]}"
export DISABLE_FIREWALL

if [ -f ~/init-firewall ]; then
    ~/init-firewall || true
fi

# Handle sudo access based on --enable-sudo flag
# Note: claude user already has sudoers entry from Dockerfile
if [ "$ENABLE_SUDO" != "true" ]; then
    # Remove sudo access if --enable-sudo wasn't passed
    rm -f /etc/sudoers.d/claude
fi

if [ -n "$CLAUDEBOX_PROJECT_NAME" ]; then
    CONFIG_FILE="/home/DOCKERUSER/.claudebox/projects/${CLAUDEBOX_PROJECT_NAME}/config.ini"

    if command -v uv >/dev/null 2>&1 && [ -f "$CONFIG_FILE" ] && grep -qE 'python|ml|datascience' "$CONFIG_FILE"; then
        if [ ! -d /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv ]; then
            su - DOCKERUSER -c "uv venv /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv"
            if [ -f /workspace/pyproject.toml ]; then
                su - DOCKERUSER -c "cd /workspace && uv sync"
            else
                su - DOCKERUSER -c "uv pip install --python /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/python ipython black pylint mypy flake8 pytest ruff"
            fi
        fi

        for shell_rc in /home/DOCKERUSER/.zshrc /home/DOCKERUSER/.bashrc; do
            if ! grep -q "source /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/activate" "$shell_rc"; then
                echo 'if [ -f /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/activate ]; then source /home/DOCKERUSER/.claudebox/projects/$CLAUDEBOX_PROJECT_NAME/.venv/bin/activate; fi' >> "$shell_rc"
            fi
        done
    fi
fi

cd /home/DOCKERUSER

if [[ "${SHELL_MODE:-false}" == "true" ]]; then
    # Use runuser to avoid PTY signal handling issues
    exec runuser -u DOCKERUSER -- bash -c "source /home/DOCKERUSER/.nvm/nvm.sh && cd /workspace && exec /bin/zsh"
else
    # Claude mode - handle wrapper logic directly here
    if [[ "${1:-}" == "update" ]]; then
        # Special update handling - pass all arguments
        shift  # Remove "update" from arguments
        exec runuser -u DOCKERUSER -- bash -c '
            export NVM_DIR="$HOME/.nvm"
            if [[ -s "$NVM_DIR/nvm.sh" ]]; then
                \. "$NVM_DIR/nvm.sh"
                nvm use default >/dev/null 2>&1 || {
                    echo "Warning: Failed to activate default Node version" >&2
                }
            else
                echo "Warning: NVM not found at $NVM_DIR" >&2
            fi
            
            cd /workspace
            echo "Running update command..."
            
            # Check for stale update lock (older than 5 minutes)
            lock_file="$HOME/.claude/.update.lock"
            if [[ -f "$lock_file" ]]; then
                lock_age=$(( $(date +%s) - $(stat -f %m "$lock_file" 2>/dev/null || stat -c %Y "$lock_file" 2>/dev/null || echo 0) ))
                if [[ $lock_age -gt 300 ]]; then
                    rm -f "$lock_file"
                fi
            fi
            
            # Capture the output of claude update to check if already up to date
            update_output=$(claude update 2>&1)
            echo "$update_output"
            
            # Only run version check if an actual update occurred
            if echo "$update_output" | grep -q "Successfully updated\|Installing update"; then
                echo "Verifying update..."
                claude --version
            fi
        '
    else
        # Regular claude execution
        exec runuser -u DOCKERUSER -- bash -c '
            export NVM_DIR="$HOME/.nvm"
            if [[ -s "$NVM_DIR/nvm.sh" ]]; then
                \. "$NVM_DIR/nvm.sh"
                nvm use default >/dev/null 2>&1 || {
                    echo "Warning: Failed to activate default Node version" >&2
                }
            else
                echo "Warning: NVM not found at $NVM_DIR" >&2
            fi
            
            cd /workspace
            
            # If no arguments and stdin is a terminal, run claude in interactive mode
            if [[ $# -eq 0 ]] && [[ -t 0 ]]; then
                exec claude
            else
                exec claude "$@"
            fi
        ' -- "$@"
    fi
fi
EOF
}

run_docker_build() {
    info "Running docker build..."
    DOCKER_BUILDKIT=1 docker build \
        --build-arg USER_ID="$USER_ID" \
        --build-arg GROUP_ID="$GROUP_ID" \
        --build-arg USERNAME="$DOCKER_USER" \
        --build-arg NODE_VERSION="$NODE_VERSION" \
        --build-arg DELTA_VERSION="$DELTA_VERSION" \
        --build-arg REBUILD_TIMESTAMP="${CLAUDEBOX_REBUILD_TIMESTAMP:-}" \
        -f "$1" -t "$IMAGE_NAME" "$2"
}

cleanup_lock_file() {
    if [[ -n "${CLAUDEBOX_LOCK_FILE:-}" ]] && [[ -f "$CLAUDEBOX_LOCK_FILE" ]]; then
        rm -f "$CLAUDEBOX_LOCK_FILE"
    fi
}

main() {
    # Set up cleanup trap
    trap cleanup_lock_file EXIT
    
    update_symlink
    local project_folder_name
    project_folder_name=$(get_project_folder_name "$PROJECT_DIR" 2>/dev/null || echo "")
    # If no project folder, we'll handle it later in the initialization check
    if [[ -n "$project_folder_name" ]]; then
        IMAGE_NAME="claudebox-${project_folder_name}"
    fi
    local docker_status
    docker_status=$(check_docker; echo $?)
    case $docker_status in
        1) install_docker ;;
        2)
            warn "Docker is installed but not running."
            warn "Starting Docker requires sudo privileges..."
            sudo systemctl start docker
            docker info &>/dev/null || error "Failed to start Docker"
            docker ps &>/dev/null || configure_docker_nonroot
            ;;
        3)
            warn "Docker requires sudo. Setting up non-root access..."
            configure_docker_nonroot
            ;;
    esac

    local args=("$@")
    local new_args=()
    local found_rebuild=false
    local host_mode=false
    local found_init=false

    local init_path=""
    local skip_next=false
    
    for i in "${!args[@]}"; do
        if [[ "$skip_next" == "true" ]]; then
            skip_next=false
            continue
        fi
        
        local arg="${args[$i]}"
        
        if [[ "$arg" == "rebuild" ]]; then
            found_rebuild=true
        elif [[ "$arg" == "--verbose" ]]; then
            VERBOSE=true
        elif [[ "$arg" == "--host-mode" ]]; then
            host_mode=true
        elif [[ "$arg" == "init" ]]; then
            found_init=true
            # Check if next arg is a path
            local next_arg="${args[$((i+1))]:-}"
            if [[ -n "$next_arg" ]] && [[ ! "$next_arg" =~ ^- ]] && [[ "$next_arg" != "profile" ]]; then
                init_path="$next_arg"
                skip_next=true
            fi
        else
            new_args+=("$arg")
        fi
    done
    
    # Update arguments to exclude consumed commands (init, rebuild, etc.)
    set -- "${new_args[@]}"
    
    # Export for use in run_container function
    export CLAUDEBOX_HOST_MODE="$host_mode"
    
    # If init with path, change to that directory
    if [[ "$found_init" == "true" ]] && [[ -n "$init_path" ]]; then
        if [[ -d "$init_path" ]]; then
            cd "$init_path" || error "Cannot access directory: $init_path"
            PROJECT_DIR="$(pwd)"
        else
            error "Directory not found: $init_path"
        fi
    fi
    
    # Migrate old project folders if needed
    if [[ -d "$HOME/.claudebox/projects" ]]; then
        for old_dir in "$HOME/.claudebox/projects"/*; do
            [[ -d "$old_dir" ]] || continue
            local old_name=$(basename "$old_dir")
            
            # Skip if already in new format (ends with 8 hex chars)
            if [[ "$old_name" =~ _[0-9a-f]{8}$ ]]; then
                continue
            fi
            
            # Get the original path from config.ini
            local config_file="$old_dir/config.ini"
            if [[ -f "$config_file" ]]; then
                local original_path=$(read_config_value "$config_file" "project" "path")
                if [[ -n "$original_path" ]] && [[ "$original_path" != "(unknown)" ]]; then
                    # Calculate new hash
                    local new_hash=$(fnv1a_32 "$original_path")
                    local new_hash_suffix="${new_hash#0x}"
                    
                    local clean_name
                    clean_name=$(echo "$original_path" | tr '[:upper:]' '[:lower:]')
                    clean_name="${clean_name//\//_}"
                    clean_name="${clean_name#_}"
                    
                    local new_name="${clean_name}_${new_hash_suffix}"
                    local new_dir="$HOME/.claudebox/projects/$new_name"
                    
                    # Rename if new name doesn't exist
                    if [[ ! -d "$new_dir" ]]; then
                        mv "$old_dir" "$new_dir" 2>/dev/null || true
                    fi
                fi
            fi
        done
    fi
    
    # Check if this folder has been initialized
    if [[ "$found_init" != "true" ]] && [[ "${1:-}" != "info" ]] && ! check_if_initialized "$PROJECT_DIR"; then
        show_project_status "not_initialized"
        exit 0
    fi
    
    # Set up project variables early - needed by multiple sections
    local project_folder_name
    if [[ "${1:-}" != "info" ]]; then
        if [[ "$found_init" == "true" ]]; then
            # Force creation of new folder when init is used
            project_folder_name=$(get_project_folder_name "$PROJECT_DIR" "true")
        else
            project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
            # Check if get_project_folder_name failed
            if [[ $? -ne 0 ]]; then
                # This means no parent folder exists - should not happen here because check_if_initialized should catch it
                show_project_status "not_initialized"
                exit 0
            fi
        fi
        IMAGE_NAME="claudebox-${project_folder_name}"
        PROJECT_CLAUDEBOX_DIR="$HOME/.claudebox/projects/$project_folder_name"
    fi

    if [[ "$found_rebuild" == "true" ]]; then
        warn "Rebuilding ClaudeBox Docker image (no cache)..."
        if docker image inspect "$IMAGE_NAME" &>/dev/null; then
            # Remove the specific container for this project
            docker rm -f "$IMAGE_NAME" 2>/dev/null || true
            # Remove any old labeled containers
            docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
            docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
        fi
        export CLAUDEBOX_NO_CACHE=true
        set -- "${new_args[@]}"
    fi

    if [[ "${1:-}" != "info" ]]; then
        mkdir -p "$PROJECT_CLAUDEBOX_DIR"
        
        # Handle config.ini symlinking for hash-chained folders
        if [[ "$found_init" == "true" ]] || ! check_if_initialized "$PROJECT_DIR"; then
            # Find the original config.ini if this is a hash-chained folder
            local clean_name
            clean_name=$(echo "$PROJECT_DIR" | tr '[:upper:]' '[:lower:]')
            clean_name="${clean_name//\//_}"
            clean_name="${clean_name#_}"
            
            local original_config=""
            local projects_dir="$HOME/.claudebox/projects"
            
            # Look for existing folders with same base name
            if [[ -d "$projects_dir" ]]; then
                for dir in "$projects_dir"/${clean_name}_*; do
                    if [[ -d "$dir" ]] && [[ -f "$dir/config.ini" ]] && [[ "$dir" != "$PROJECT_CLAUDEBOX_DIR" ]]; then
                        original_config="$dir/config.ini"
                        break
                    fi
                done
            fi
            
            # If we found an original config and our config doesn't exist, symlink it
            if [[ -n "$original_config" ]] && [[ ! -e "$PROJECT_CLAUDEBOX_DIR/config.ini" ]]; then
                ln -s "$original_config" "$PROJECT_CLAUDEBOX_DIR/config.ini"
            fi
        fi
    fi

    # Check for help flags early - only check first argument
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" || "${1:-}" == "help" ]]; then
        show_help
        exit 0
    fi

    [[ "$VERBOSE" == "true" ]] && echo "Command: ${1:-none}" >&2
    
    # Save original directory for returning after exit
    export CLAUDEBOX_ORIGINAL_PWD="$PWD"
    
    # Check if first argument is a hash (8 hex chars) for direct project launch
    if [[ "${1:-}" =~ ^[0-9a-fA-F]{8}$ ]]; then
        local hash_arg="$1"  # Save the hash before shifting
        local target_project
        target_project=$(find_project_by_hash "$hash_arg")
        if [[ -n "$target_project" ]]; then
            shift # Remove hash from args
            
            # Get the original project path from config
            local config_file="$HOME/.claudebox/projects/$target_project/config.ini"
            if [[ -f "$config_file" ]]; then
                local original_path=$(read_config_value "$config_file" "project" "path")
                if [[ -n "$original_path" ]] && [[ -d "$original_path" ]]; then
                    # Launch in the original project directory
                    cd "$original_path" || error "Cannot access project directory: $original_path"
                    exec "$0" "$@"
                else
                    error "Project path not found or invalid for hash: $hash_arg"
                fi
            else
                error "Project configuration not found for hash: $hash_arg"
            fi
        else
            error "No project found with hash: $hash_arg"
        fi
    fi
    
    # Check if first argument is a path
    if [[ "${1:-}" =~ ^/ ]] || [[ -d "${1:-}" ]]; then
        local path_arg="$1"
        shift # Remove path from args
        
        # Check if it's an absolute path or resolve it
        local target_path
        if [[ "$path_arg" =~ ^/ ]]; then
            target_path="$path_arg"
        else
            target_path="$(cd "$path_arg" 2>/dev/null && pwd)" || target_path=""
        fi
        
        if [[ -n "$target_path" ]] && [[ -d "$target_path" ]]; then
            local target_project
            target_project=$(get_project_by_path "$target_path")
            if [[ -n "$target_project" ]]; then
                cd "$target_path" || error "Cannot access project directory: $target_path"
                exec "$0" "$@"
            else
                error "No project found at path: $path_arg"
            fi
        else
            # Not a valid path, might be a workspace-relative name
            local workspace_file="$HOME/.claudebox/workpath"
            if [[ -f "$workspace_file" ]]; then
                local workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
                if [[ -n "$workspace" ]]; then
                    local full_path="$workspace/$path_arg"
                    if [[ -d "$full_path" ]]; then
                        local target_project
                        target_project=$(get_project_by_path "$full_path")
                        if [[ -n "$target_project" ]]; then
                            cd "$full_path" || error "Cannot access project directory: $full_path"
                            exec "$0" "$@"
                        fi
                    fi
                fi
            fi
        fi
    fi
    
    # First, handle commands that don't require Docker image
    case "${1:-}" in
            
        profiles)
            shift
            cecho "Available ClaudeBox Profiles:" "$CYAN"
            echo
            for profile in $(get_all_profile_names | tr ' ' '\n' | sort); do
                local desc=$(get_profile_description "$profile")
                echo -e "  ${GREEN}$profile${NC} - $desc"
            done
            exit 0
            ;;

        projects)
            # Standalone projects command - direct to list
            shift
            show_projects_list
            exit 0
            ;;
            
        project)
            shift
            case "${1:-}" in
                list|--list|-l)
                    shift
                    show_projects_list
                    exit 0
                    ;;
                    
                init)
                    # Same as regular init but clearer naming
                    found_init=true
                    set -- "${@:2}"  # Remove 'project init' from args
                    ;;
                    
                launch|open|go)
                    shift
                    if [[ -z "$1" ]]; then
                        error "Please specify a project hash or path"
                    fi
                    # Launch project by hash or path
                    local target_project
                    target_project=$(resolve_project_path "$1")
                    if [[ -n "$target_project" ]]; then
                        shift
                        local config_file="$HOME/.claudebox/projects/$target_project/config.ini"
                        if [[ -f "$config_file" ]]; then
                            local original_path=$(read_config_value "$config_file" "project" "path")
                            if [[ -n "$original_path" ]] && [[ -d "$original_path" ]]; then
                                cd "$original_path" || error "Cannot access project directory: $original_path"
                                exec "$0" "$@"
                            fi
                        fi
                    fi
                    error "Project not found: $1"
                    ;;
                    
                clean)
                    # Forward to clean project command
                    shift
                    exec "$0" clean project "$@"
                    ;;
                    
                example|examples)
                    cecho "ClaudeBox Project Examples:" "$CYAN"
                    echo
                    cecho "🚀 Initialization:" "$WHITE"
                    echo "  # Initialize new project with profiles"
                    echo "  claudebox project init profile python ml"
                    echo "  claudebox init profile rust go           # Shorthand"
                    echo
                    cecho "📋 Launching Projects:" "$WHITE"
                    echo "  # Launch specific project by hash"
                    echo "  claudebox project launch 11c26114"
                    echo "  claudebox 11c26114                       # Direct hash launch"
                    echo
                    cecho "🧹 Cleaning Projects:" "$WHITE"
                    echo "  # Clean current project"
                    echo "  claudebox project clean data"
                    echo "  claudebox project clean all"
                    echo
                    echo "  # Clean specific projects"
                    echo "  claudebox project clean /path/to/project all"
                    echo "  claudebox project clean 11c26114 docker"
                    echo
                    echo "  # Clean multiple projects at once"
                    echo "  claudebox project clean /foo /bar 11c26114 all"
                    echo
                    echo "  # Clean all unknown projects"
                    echo "  claudebox project clean unknown all"
                    echo
                    cecho "🔄 Multiple Instances:" "$WHITE"
                    echo "  # Create additional instance for same project"
                    echo "  cd /your/project"
                    echo "  claudebox init                           # Creates new hash-chained folder"
                    echo
                    exit 0
                    ;;
                    
                *)
                    # Check if an argument was provided - might be a project path
                    if [[ -n "${1:-}" ]]; then
                        local project_arg="$1"
                        local target_path=""
                        
                        # Check if it's an absolute path
                        if [[ "$project_arg" =~ ^/ ]]; then
                            target_path="$project_arg"
                        else
                            # Try workspace-relative
                            local workspace_file="$HOME/.claudebox/workpath"
                            if [[ -f "$workspace_file" ]]; then
                                local workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
                                if [[ -n "$workspace" ]]; then
                                    target_path="$workspace/$project_arg"
                                fi
                            fi
                        fi
                        
                        # If we have a valid path, show project details
                        if [[ -n "$target_path" ]] && [[ -d "$target_path" ]]; then
                            cecho "Project: $target_path" "$CYAN"
                            echo
                            
                            # Count slots
                            local total_slots=0
                            local active_instances=0
                            local ready_slots=0
                            
                            for project_dir in "$HOME/.claudebox/projects"/*/ ; do
                                [[ -d "$project_dir" ]] || continue
                                local config_file="$project_dir/config.ini"
                                local this_path="(unknown)"
                                
                                if [[ -f "$config_file" ]]; then
                                    local path_value=$(read_config_value "$config_file" "project" "path")
                                    [[ -n "$path_value" ]] && this_path="$path_value"
                                fi
                                
                                if [[ "$this_path" == "$target_path" ]]; then
                                    total_slots=$((total_slots + 1))
                                    local lock_file="$project_dir/.lock"
                                    if [[ -f "$lock_file" ]]; then
                                        local pid=$(cat "$lock_file" 2>/dev/null || echo "")
                                        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                                            active_instances=$((active_instances + 1))
                                        else
                                            ready_slots=$((ready_slots + 1))
                                        fi
                                    else
                                        ready_slots=$((ready_slots + 1))
                                    fi
                                fi
                            done
                            
                            echo "Total slots: $total_slots"
                            echo
                            cecho "Slot Status:" "$WHITE"
                            list_project_slots "$target_path"
                            echo
                            echo "Instances: $active_instances, Ready: $ready_slots, Empty: $((total_slots - active_instances - ready_slots))"
                            exit 0
                        fi
                    fi
                    
                    # Default help menu
                    cecho "╔════════════════════════════════════════════════════════════════════════╗" "$CYAN"
                    cecho "║                       ClaudeBox Project Management                     ║" "$CYAN"
                    cecho "╚════════════════════════════════════════════════════════════════════════╝" "$CYAN"
                    echo
                    
                    cecho "📋 Commands:" "$WHITE"
                    echo -e "  ${GREEN}claudebox project list${NC}              List all projects with status"
                    echo -e "  ${GREEN}claudebox project <name>${NC}            Show project slot details"
                    echo -e "  ${GREEN}claudebox project init${NC}              Initialize new project in current directory"
                    echo -e "  ${GREEN}claudebox project launch <hash>${NC}     Launch project by 8-char hash"
                    echo -e "  ${GREEN}claudebox project clean${NC}             Clean project data"
                    echo -e "  ${GREEN}claudebox project examples${NC}          Show usage examples"
                    echo
                    
                    cecho "🚀 Quick Launch:" "$WHITE"
                    echo -e "  ${GREEN}claudebox <hash>${NC}                    Direct launch by project hash"
                    echo -e "  ${GREEN}claudebox${NC}                           Launch in current directory"
                    echo
                    
                    cecho "ℹ️  Project Structure:" "$CYAN"
                    echo "  Each project gets a unique folder based on path + hash:"
                    echo "  ~/.claudebox/projects/<path>_<hash>/"
                    echo "    ├── config.ini     (profiles & packages)"
                    echo "    ├── .claude/       (Claude AI data)"
                    echo "    ├── .claude.json   (Claude config)"
                    echo "    ├── .config/       (Tool configs)"
                    echo "    └── .cache/        (Cache data)"
                    echo
                    
                    cecho "🔄 Multiple Instances:" "$CYAN"
                    echo "  Run 'claudebox init' again to create additional instances"
                    echo "  Each instance gets a new hash-chained folder"
                    echo "  All instances share the same config.ini via symlinks"
                    echo
                    echo -e "${YELLOW}Run 'claudebox project examples' for usage examples${NC}"
                    exit 0
                    ;;
            esac
            ;;

        profile)
            shift

            local project_folder_name
            project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
            local profile_file
            profile_file=$(get_profile_file_path)

            case "${1:-}" in
                list|--list|-l)

                    cecho "Available ClaudeBox Profiles:" "$CYAN"
                    echo
                    for profile in $(get_all_profile_names | tr ' ' '\n' | sort); do
                        local desc=$(get_profile_description "$profile")
                        echo -e "  ${GREEN}$profile${NC} - $desc"
                    done
                    exit 0
                    ;;

                status|--status|-s)

                    cecho "Project: $PROJECT_DIR" "$CYAN"
                    echo
                    if [[ -f "$profile_file" ]]; then
                        local current_profiles=()
                        readarray -t current_profiles < <(read_profile_section "$profile_file" "profiles")
                        if [[ ${#current_profiles[@]} -gt 0 ]]; then
                            cecho "Active profiles: ${current_profiles[*]}" "$GREEN"
                        else
                            cecho "No profiles installed" "$YELLOW"
                        fi

                        local current_packages=()
                        readarray -t current_packages < <(read_profile_section "$profile_file" "packages")
                        if [[ ${#current_packages[@]} -gt 0 ]]; then
                            echo "Extra packages: ${current_packages[*]}"
                        fi
                    else
                        cecho "No profiles configured for this project" "$YELLOW"
                    fi
                    exit 0
                    ;;

                example|examples)
                    cecho "ClaudeBox Profile Examples:" "$CYAN"
                    echo
                    cecho "📋 Viewing Profiles:" "$WHITE"
                    echo "  claudebox profiles                       # List all available profiles"
                    echo "  claudebox profile status                 # Check current project's profiles"
                    echo
                    cecho "🛠️ Installing Profiles:" "$WHITE"
                    echo "  # Single profile"
                    echo "  claudebox profile python"
                    echo "  claudebox profile rust"
                    echo
                    echo "  # Multiple profiles"
                    echo "  claudebox profile python ml"
                    echo "  claudebox profile c embedded openwrt"
                    echo
                    echo "  # With init (new project)"
                    echo "  claudebox init profile python ml"
                    echo "  claudebox profile init rust go           # Works in any order"
                    echo
                    cecho "📦 Common Combinations:" "$WHITE"
                    echo "  claudebox profile python ml              # Python + Machine Learning"
                    echo "  claudebox profile javascript web         # JS + Web Development"
                    echo "  claudebox profile c embedded             # C + Embedded Systems"
                    echo "  claudebox profile go devops              # Go + DevOps Tools"
                    echo
                    exit 0
                    ;;
                    
                "")

                    cecho "ClaudeBox Profile Management:" "$CYAN"
                    echo
                    echo -e "  ${GREEN}profiles${NC}                 Show all available profiles"
                    echo -e "  ${GREEN}profile status${NC}           Show current project's profiles"
                    echo -e "  ${GREEN}profile <names...>${NC}       Install profiles"
                    echo -e "  ${GREEN}profile examples${NC}         Show usage examples"
                    echo
                    echo -e "${YELLOW}Run 'claudebox profile examples' for usage examples${NC}"
                    exit 0
                    ;;
            esac

            local selected=() remaining=()
            while [[ $# -gt 0 ]]; do

                if profile_exists "$1"; then
                    selected+=("$1")
                    shift
                else
                    remaining=("$@")
                    break
                fi
            done

            [[ ${#selected[@]} -eq 0 ]] && error "No valid profiles specified\nRun 'claudebox profile' to see available profiles"

            local profile_file
            profile_file=$(get_profile_file_path)


            update_profile_section "$profile_file" "profiles" "${selected[@]}"

            local all_profiles=()
            readarray -t all_profiles < <(read_profile_section "$profile_file" "profiles")

            cecho "Profile: $PROJECT_DIR" "$CYAN"
            cecho "Installing profiles: ${selected[*]}" "$PURPLE"
            if [[ ${#all_profiles[@]} -gt 0 ]]; then
                cecho "All active profiles: ${all_profiles[*]}" "$GREEN"
            fi
            echo

            if [[ ${#remaining[@]} -gt 0 ]]; then
                set -- "${remaining[@]}"
            fi
            ;;
        save)
            shift
            defaults_file="$HOME/.claudebox/default-flags"

            if [[ $# -eq 0 ]]; then
                if [[ -f "$defaults_file" ]]; then
                    rm -f "$defaults_file"
                    success "Cleared saved default flags"
                else
                    info "No saved default flags to clear"
                fi
            else
                mkdir -p "$HOME/.claudebox"
                printf '%s\n' "$@" > "$defaults_file"
                success "Saved default flags: $*"
            fi
            exit 0
                        ;;
        install)
            shift
            [[ $# -eq 0 ]] && error "No packages specified. Usage: claudebox install <package1> <package2> ..."

            local profile_file
            profile_file=$(get_profile_file_path)

            update_profile_section "$profile_file" "packages" "$@"

            local all_packages=()
            readarray -t all_packages < <(read_profile_section "$profile_file" "packages")

            cecho "Profile: $PROJECT_DIR" "$CYAN"
            cecho "Installing packages: $*" "$PURPLE"
            if [[ ${#all_packages[@]} -gt 0 ]]; then
                cecho "All packages: ${all_packages[*]}" "$GREEN"
            fi
            echo
            ;;

        unlink)
            if [[ -L "$LINK_TARGET" ]]; then
                rm -f "$LINK_TARGET"
                success "Removed claudebox symlink from $(dirname "$LINK_TARGET")"
            else
                info "No claudebox symlink found at $LINK_TARGET"
            fi
            exit 0
            ;;

        shell)
            shift
            # Check if image exists first
            if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                error "No Docker image found for this project folder: $PROJECT_DIR\nRun 'claudebox' first to build the image, or cd to your project directory."
            fi
            
            local persist_mode=false
            local shell_flags=()
            
            # Check if first arg is "admin"
            if [[ "${1:-}" == "admin" ]]; then
                persist_mode=true
                shift
                # In admin mode, automatically enable sudo and disable firewall
                shell_flags+=("--enable-sudo" "--disable-firewall")
            fi
            
            # Process remaining flags (only for non-persist mode)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --enable-sudo|--disable-firewall)
                        if [[ "$persist_mode" == "false" ]]; then
                            shell_flags+=("$1")
                        fi
                        shift
                        ;;
                    *)
                        warn "Unknown shell flag: $1"
                        shift
                        ;;
                esac
            done

            echo
            logo
            echo
            
            # Run container for shell
            if [[ "$persist_mode" == "true" ]]; then
                cecho "Administration Mode" "$YELLOW"
                echo "Sudo enabled, firewall disabled."
                echo "Changes will be saved to the image when you exit."
                echo
                
                # Create a named container for admin mode so we can commit it
                local project_folder_name
                project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
                local temp_container="claudebox-shell-${project_folder_name}-$$"
                
                # Ensure cleanup runs on any exit (including Ctrl-C)
                cleanup_admin() {
                    docker commit "$temp_container" "$IMAGE_NAME" >/dev/null 2>&1
                    docker rm -f "$temp_container" >/dev/null 2>&1
                }
                trap cleanup_admin EXIT
                
                run_claudebox_container "$temp_container" "interactive" --shell-mode "${shell_flags[@]}"
                
                # Commit changes back to image
                fillbar
                docker commit "$temp_container" "$IMAGE_NAME" >/dev/null
                docker rm -f "$temp_container" >/dev/null 2>&1
                fillbar stop
                success "Changes saved to image!"
            else
                # Regular shell mode - just run without committing
                run_claudebox_container "" "interactive" --shell-mode "${shell_flags[@]}"
            fi
            
            exit 0
            ;;

        update)
            # Handle update all specially
            if [[ "${2:-}" == "all" ]]; then
                info "Updating all components..."
                echo
                
                # Update claudebox script
                info "Updating claudebox script..."
                if command -v curl >/dev/null 2>&1; then
                    curl -fsSL https://raw.githubusercontent.com/RchGrav/claudebox/main/claudebox -o /tmp/claudebox.new
                elif command -v wget >/dev/null 2>&1; then
                    wget -qO /tmp/claudebox.new https://raw.githubusercontent.com/RchGrav/claudebox/main/claudebox
                else
                    error "Neither curl nor wget found"
                fi
                
                if [[ -f /tmp/claudebox.new ]]; then
                    # Find the installed claudebox (not the source)
                    local installed_path=$(which claudebox 2>/dev/null || echo "/usr/local/bin/claudebox")
                    
                    # If it's a symlink, replace it with the actual file first
                    if [[ -L "$installed_path" ]]; then
                        info "Converting symlink to real file..."
                        local source_file=$(readlink -f "$installed_path")
                        if [[ -w "$(dirname "$installed_path")" ]]; then
                            cp "$source_file" "$installed_path.tmp"
                            mv "$installed_path.tmp" "$installed_path"
                            chmod +x "$installed_path"
                        else
                            sudo cp "$source_file" "$installed_path.tmp"
                            sudo mv "$installed_path.tmp" "$installed_path"
                            sudo chmod +x "$installed_path"
                        fi
                    fi
                    
                    # Compare hashes of the INSTALLED file
                    current_hash=$(cat "$installed_path" 2>/dev/null | fnv1a_32 || echo "none")
                    new_hash=$(cat /tmp/claudebox.new | fnv1a_32)
                    
                    if [[ "$current_hash" != "$new_hash" ]]; then
                        info "New version available, updating..."
                        
                        # Backup current installed version
                        local backups_dir="$HOME/.claudebox/backups"
                        mkdir -p "$backups_dir"
                        local timestamp=$(date +%s)
                        cp "$installed_path" "$backups_dir/$timestamp"
                        info "Backed up current version to $backups_dir/$timestamp"
                        
                        # Update the INSTALLED file
                        if [[ -w "$installed_path" ]] || [[ -w "$(dirname "$installed_path")" ]]; then
                            cp /tmp/claudebox.new "$installed_path"
                            chmod +x "$installed_path"
                        else
                            sudo cp /tmp/claudebox.new "$installed_path"
                            sudo chmod +x "$installed_path"
                        fi
                        success "✓ Claudebox script updated at $installed_path"
                    else
                        success "✓ Claudebox script already up to date"
                    fi
                    rm -f /tmp/claudebox.new
                fi
                echo
                
                # Update commands
                info "Updating commands..."
                local commands_dir="$HOME/.claudebox/commands"
                mkdir -p "$commands_dir"
                
                for cmd in taskengine devops; do
                    echo -n "  Updating $cmd.md... "
                    if command -v curl >/dev/null 2>&1; then
                        curl -fsSL "https://raw.githubusercontent.com/RchGrav/claudebox/main/commands/$cmd.md" -o "$commands_dir/$cmd.md"
                    else
                        wget -qO "$commands_dir/$cmd.md" "https://raw.githubusercontent.com/RchGrav/claudebox/main/commands/$cmd.md"
                    fi
                    echo "✓"
                done
                echo
                
                # Now update Claude
                info "Updating Claude..."
                shift # Remove "update"
                shift # Remove "all"
                set -- "update" "$@" # Put back just "update"
            fi
            
            # Check if image exists first
            if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                error "No Docker image found for this project folder: $PROJECT_DIR\nRun 'claudebox' first to build the image, or cd to your project directory."
            fi
            
            # Continue with normal update flow
            ;&  # Fall through to next case
            
        config|mcp|migrate-installer)
            # Check if image exists first (for non-update commands)
            if [[ "$1" != "update" ]] && ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                error "No Docker image found for this project folder: $PROJECT_DIR\nRun 'claudebox' first to build the image, or cd to your project directory."
            fi
            
            # Create temporary container
            local temp_container="claudebox-temp-${project_folder_name}-$$"
            
            # Run container with all arguments passed through
            run_claudebox_container "$temp_container" "detached" "$@" >/dev/null
            
            # Show progress while waiting
            if [[ "$1" == "update" ]]; then
                # Show hint during update
                echo
                cecho "Hint:" "$YELLOW"
                echo "  claudebox update all            # Pull the latest claudebox features!"
                echo
            fi
            fillbar
            
            # Wait for container to finish
            docker wait "$temp_container" >/dev/null
            
            fillbar stop
            
            # Show container output for commands that produce output
            docker logs "$temp_container" 2>&1
            
            # For update command, show version after update
            if [[ "$1" == "update" ]]; then
                docker exec -u "$DOCKER_USER" "$temp_container" bash -c "
                    source \$HOME/.nvm/nvm.sh && nvm use default >/dev/null 2>&1 && claude --version
                " 2>/dev/null || true
            fi

            # Commit changes back to image
            docker commit "$temp_container" "$IMAGE_NAME" >/dev/null
            docker stop "$temp_container" >/dev/null 2>&1 || true
            docker rm "$temp_container" >/dev/null 2>&1 || true
            
            exit 0
            ;;

        allowlist)
            shift
            local allowlist_file="$PROJECT_CLAUDEBOX_DIR/allowlist"

            cecho "🔒 ClaudeBox Firewall Allowlist" "$CYAN"
            echo
            cecho "Current Project: $PROJECT_DIR" "$WHITE"
            echo

            if [[ -f "$allowlist_file" ]]; then
                cecho "Allowlist file:" "$GREEN"
                echo "  $allowlist_file"
                echo
                cecho "Allowed domains:" "$CYAN"
                # Display allowlist contents
                while IFS= read -r line; do
                    if [[ -n "$line" ]] && [[ ! "$line" =~ ^#.* ]]; then
                        echo "  $line"
                    fi
                done < "$allowlist_file"
                echo
            else
                cecho "Allowlist file:" "$YELLOW"
                echo "  Not yet created (will be created on first run)"
                echo "  Location: $allowlist_file"
            fi

            echo
            cecho "Default Allowed Domains:" "$CYAN"
            echo "  api.anthropic.com, console.anthropic.com, statsig.anthropic.com, sentry.io"
            echo
            cecho "To edit allowlist:" "$YELLOW"
            echo "  \$EDITOR $allowlist_file"
            echo
            cecho "Note:" "$WHITE"
            echo "  Changes take effect on next container start"
            echo "  Use --disable-firewall flag to bypass all restrictions"

            exit 0
            ;;

        clean)
            shift
            case "${1:-}" in
                all)
                    warn "Complete Docker cleanup: removing all claudebox containers, images, volumes, and cache..."
                    # Remove all claudebox containers
                    docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
                    docker ps -a --format "{{.Names}}" | grep "^claudebox-" | xargs -r docker rm -f 2>/dev/null || true

                    # Remove ALL claudebox images (including base)
                    docker images --filter "reference=claudebox-*" -q | xargs -r docker rmi -f 2>/dev/null || true
                    docker images --filter "reference=claudebox" -q | xargs -r docker rmi -f 2>/dev/null || true

                    # Remove dangling images
                    docker images -f "dangling=true" -q | xargs -r docker rmi -f 2>/dev/null || true

                    # Prune build cache
                    docker builder prune -af 2>/dev/null || true

                    # Remove volumes
                    docker volume ls -q --filter "name=claudebox" | xargs -r docker volume rm 2>/dev/null || true

                    success "Docker cleanup complete!"
                    ;;
                image)
                    warn "Removing ClaudeBox containers and image..."
                    # Remove any containers from this image
                    docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
                    # Remove orphaned containers from images that no longer exist
                    # This is safer as it only removes containers whose images are gone
                    docker ps -a --filter "status=exited" --format "{{.ID}} {{.Image}}" | while read id image; do
                        if ! docker image inspect "$image" >/dev/null 2>&1; then
                            docker rm -f "$id" 2>/dev/null || true
                        fi
                    done
                   # Remove all claudebox project images
                   docker images --filter "reference=claudebox-*" -q | xargs -r docker rmi -f 2>/dev/null || true
                    docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
                    success "Containers and image removed! Build cache preserved."
                    ;;
                cache)
                    warn "Cleaning Docker build cache..."
                    docker builder prune -af
                    success "Build cache cleaned!"
                    ;;
                volumes)
                    warn "Removing ClaudeBox-related volumes..."
                    docker volume ls -q --filter "name=claudebox" | xargs -r docker volume rm 2>/dev/null || true
                    docker volume prune -f 2>/dev/null || true
                    success "Volumes cleaned!"
                    ;;
                containers)
                    warn "Cleaning ClaudeBox containers..."
                    # Remove any containers from this image
                    docker ps -a --filter "label=claudebox.project" -q | xargs -r docker rm -f 2>/dev/null || true
                    # Remove orphaned containers from images that no longer exist
                    # This is safer as it only removes containers whose images are gone
                    docker ps -a --filter "status=exited" --format "{{.ID}} {{.Image}}" | while read id image; do
                        if ! docker image inspect "$image" >/dev/null 2>&1; then
                            docker rm -f "$id" 2>/dev/null || true
                        fi
                    done
                    success "Containers cleaned!"
                    ;;
                dangling)
                    warn "Removing dangling images and unused containers..."
                    docker image prune -f
                    docker container prune -f
                    success "Dangling resources cleaned!"
                    ;;
                logs)
                    warn "Clearing Docker container logs..."
                    docker ps -a --filter "label=claudebox.project" -q | while read -r container; do
                        docker logs "$container" >/dev/null 2>&1 && echo -n | docker logs "$container" 2>/dev/null || true
                    done
                    success "Container logs cleared!"
                    ;;
                project)
                    shift

                    # Collect projects to clean
                    local projects_to_clean=()
                    local clean_unknown=false
                    local action=""
                    
                    # Parse arguments
                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            all|data|docker|profiles|tools)
                                action="$1"
                                shift
                                break
                                ;;
                            unknown)
                                clean_unknown=true
                                shift
                                ;;
                            *)
                                # Try to resolve as project path or hash
                                local resolved
                                resolved=$(resolve_project_path "$1")
                                if [[ -n "$resolved" ]]; then
                                    projects_to_clean+=("$resolved")
                                else
                                    error "No ClaudeBox project found: $1"
                                fi
                                shift
                                ;;
                        esac
                    done
                    
                    # Add unknown projects if requested
                    if [[ "$clean_unknown" == "true" ]]; then
                        if [[ -d "$HOME/.claudebox/projects" ]]; then
                            for project_dir in "$HOME/.claudebox/projects"/*/; do
                                [[ -d "$project_dir" ]] || continue
                                local project_id=$(basename "$project_dir")
                                local config_file="$project_dir/config.ini"
                                local is_unknown=true
                                
                                if [[ -f "$config_file" ]]; then
                                    local path_value=$(read_config_value "$config_file" "project" "path")
                                    if [[ -n "$path_value" ]] && [[ "$path_value" != "(unknown)" ]]; then
                                        is_unknown=false
                                    fi
                                fi
                                
                                if [[ "$is_unknown" == "true" ]]; then
                                    projects_to_clean+=("$project_id")
                                fi
                            done
                        fi
                    fi
                    
                    # If no projects specified, use current directory
                    if [[ ${#projects_to_clean[@]} -eq 0 ]] && [[ "$clean_unknown" != "true" ]]; then
                        local current_project
                        current_project=$(get_project_folder_name "$PROJECT_DIR")
                        projects_to_clean+=("$current_project")
                    fi
                    
                    # If no action specified, show help
                    if [[ -z "$action" ]]; then
                        if [[ ${#projects_to_clean[@]} -gt 0 ]]; then
                            # Show what would be cleaned
                            cecho "Projects to clean:" "$YELLOW"
                            for project_id in "${projects_to_clean[@]}"; do
                                local display_path="(unknown)"
                                local config_file="$HOME/.claudebox/projects/$project_id/config.ini"
                                if [[ -f "$config_file" ]]; then
                                    local path_value=$(read_config_value "$config_file" "project" "path")
                                    [[ -n "$path_value" ]] && display_path="$path_value"
                                fi
                                echo "  - $display_path (${project_id##*_})"
                            done
                            echo
                        fi
                        
                        cecho "ClaudeBox Project Clean Options:" "$CYAN"
                        echo
                        echo -e "  ${GREEN}clean project [path/hash...] profiles${NC}   Remove installed profiles & packages"
                        echo -e "  ${GREEN}clean project [path/hash...] data${NC}       Remove project data (auth, history, configs)"
                        echo -e "  ${GREEN}clean project [path/hash...] docker${NC}     Remove project Docker image"
                        echo -e "  ${GREEN}clean project [path/hash...] all${NC}        Remove everything for projects"
                        echo -e "  ${GREEN}clean project unknown all${NC}               Remove all unknown projects"
                        echo
                        echo -e "${YELLOW}Run 'claudebox clean examples' for usage examples${NC}"
                        exit 0
                    fi
                    
                    # Perform the clean action for each project
                    for project_id in "${projects_to_clean[@]}"; do
                        local project_claudebox_dir="$HOME/.claudebox/projects/$project_id"
                        local image_name="claudebox-${project_id}"
                        local display_path="(unknown)"
                        local config_file="$project_claudebox_dir/config.ini"
                        
                        if [[ -f "$config_file" ]]; then
                            local path_value=$(read_config_value "$config_file" "project" "path")
                            [[ -n "$path_value" ]] && display_path="$path_value"
                        fi
                        
                        case "$action" in
                            profiles|tools)
                                cecho "Clearing profile configuration for: $display_path" "$YELLOW"
                                if [[ -f "$config_file" ]]; then
                                    {
                                        awk '/^\[profiles\]/ { profiles=1; print; print ""; next }
                                             /^\[packages\]/ { packages=1; print; print ""; next }
                                             /^\[/ { profiles=0; packages=0 }
                                             !profiles && !packages { print }' "$config_file"
                                    } > "${config_file}.tmp" && mv "${config_file}.tmp" "$config_file"
                                    success "  ✓ Cleared profile configuration"
                                else
                                    info "  - No configuration file found"
                                fi
                                ;;
                            data)
                                cecho "Removing project data for: $display_path" "$YELLOW"
                                if [[ -d "$project_claudebox_dir" ]]; then
                                    rm -rf "$project_claudebox_dir"
                                    success "  ✓ Removed project data folder"
                                else
                                    info "  - No project data folder found"
                                fi
                                ;;
                            docker)
                                cecho "Removing Docker image for: $display_path" "$YELLOW"
                                if docker rmi -f "$image_name" 2>/dev/null; then
                                    success "  ✓ Removed Docker image"
                                else
                                    info "  - No Docker image found"
                                fi
                                ;;
                            all)
                                cecho "Removing all artifacts for: $display_path" "$YELLOW"
                                local cleaned_something=false
                                
                                # Remove config
                                if [[ -f "$config_file" ]]; then
                                    rm -f "$config_file"
                                    success "  ✓ Removed profile configuration"
                                    cleaned_something=true
                                fi
                                
                                # Remove project folder and lock
                                if [[ -d "$project_claudebox_dir" ]]; then
                                    rm -rf "$project_claudebox_dir"
                                    success "  ✓ Removed project data folder"
                                    cleaned_something=true
                                fi
                                
                                
                                # Remove Docker image
                                if docker rmi -f "$image_name" 2>/dev/null; then
                                    success "  ✓ Removed Docker image"
                                    cleaned_something=true
                                fi
                                
                                if [[ "$cleaned_something" != "true" ]]; then
                                    info "  - No artifacts found for this project"
                                fi
                                ;;
                        esac
                    done
                    exit 0
                    ;;
                example|examples)
                    cecho "ClaudeBox Clean Examples:" "$CYAN"
                    echo
                    cecho "🐳 Docker Cleanup:" "$WHITE"
                    echo "  claudebox clean containers               # Remove all containers"
                    echo "  claudebox clean image                    # Remove containers and image"
                    echo "  claudebox clean all                      # Complete Docker cleanup"
                    echo "  claudebox clean cache                    # Clear build cache only"
                    echo
                    cecho "📁 Project Cleanup:" "$WHITE"
                    echo "  # Current project"
                    echo "  claudebox clean project data             # Remove project data"
                    echo "  claudebox clean project all              # Remove everything"
                    echo
                    echo "  # Specific projects"
                    echo "  claudebox clean project /path/to/project all"
                    echo "  claudebox clean project 11c26114 docker"
                    echo
                    echo "  # Multiple projects"
                    echo "  claudebox clean project /foo /bar 11c26114 all"
                    echo
                    echo "  # All unknown projects"
                    echo "  claudebox clean project unknown all"
                    echo
                    cecho "🧹 Maintenance:" "$WHITE"
                    echo "  claudebox clean dangling                 # Remove dangling images"
                    echo "  claudebox clean volumes                  # Remove Docker volumes"
                    echo "  claudebox clean logs                     # Clear container logs"
                    echo
                    exit 0
                    ;;
                    
                *)
                    cecho "ClaudeBox Clean Options:" "$CYAN"
                    echo
                    echo -e "  ${GREEN}clean containers${NC}         Remove all containers (preserves image)"
                    echo -e "  ${GREEN}clean project${NC}            Show project cleanup options"
                    echo -e "  ${GREEN}clean all${NC}                Remove all Docker artifacts"
                    echo -e "  ${GREEN}clean image${NC}              Remove containers and image"
                    echo -e "  ${GREEN}clean cache${NC}              Remove Docker build cache only"
                    echo -e "  ${GREEN}clean volumes${NC}            Remove associated Docker volumes"
                    echo -e "  ${GREEN}clean dangling${NC}           Remove dangling images"
                    echo -e "  ${GREEN}clean logs${NC}               Clear Docker container logs"
                    echo -e "  ${GREEN}clean examples${NC}           Show usage examples"
                    echo
                    echo -e "${YELLOW}Run 'claudebox clean examples' for usage examples${NC}"
                    exit 0
                    ;;
            esac
            echo
            docker system df
            exit 0
            ;;


        undo)
            local backups_dir="$HOME/.claudebox/backups"
            if [[ ! -d "$backups_dir" ]] || [[ -z "$(ls -A "$backups_dir" 2>/dev/null)" ]]; then
                error "No backups found"
            fi
            
            # Get oldest backup (smallest timestamp)
            local oldest=$(ls -1 "$backups_dir" | sort -n | head -1)
            local installed_path=$(which claudebox 2>/dev/null || echo "/usr/local/bin/claudebox")
            
            info "Restoring oldest backup from $(date -d @$oldest '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -r $oldest '+%Y-%m-%d %H:%M:%S')"
            
            if [[ -w "$installed_path" ]] || [[ -w "$(dirname "$installed_path")" ]]; then
                cp "$backups_dir/$oldest" "$installed_path"
                chmod +x "$installed_path"
            else
                sudo cp "$backups_dir/$oldest" "$installed_path"
                sudo chmod +x "$installed_path"
            fi
            
            success "✓ Restored claudebox from backup"
            exit 0
            ;;
            
        redo)
            local backups_dir="$HOME/.claudebox/backups"
            if [[ ! -d "$backups_dir" ]] || [[ -z "$(ls -A "$backups_dir" 2>/dev/null)" ]]; then
                error "No backups found"
            fi
            
            # Get newest backup (largest timestamp)
            local newest=$(ls -1 "$backups_dir" | sort -n | tail -1)
            local installed_path=$(which claudebox 2>/dev/null || echo "/usr/local/bin/claudebox")
            
            info "Restoring newest backup from $(date -d @$newest '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date -r $newest '+%Y-%m-%d %H:%M:%S')"
            
            if [[ -w "$installed_path" ]] || [[ -w "$(dirname "$installed_path")" ]]; then
                cp "$backups_dir/$newest" "$installed_path"
                chmod +x "$installed_path"
            else
                sudo cp "$backups_dir/$newest" "$installed_path"
                sudo chmod +x "$installed_path"
            fi
            
            success "✓ Restored claudebox from backup"
            exit 0
            ;;
            
        set)
            shift
            case "${1:-}" in
                workspace)
                    shift
                    local workspace_file="$HOME/.claudebox/workpath"
                    mkdir -p "$(dirname "$workspace_file")"
                    
                    if [[ -z "${1:-}" ]]; then
                        # No argument - show current workspace
                        if [[ -f "$workspace_file" ]]; then
                            local current_workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
                            if [[ -n "$current_workspace" ]]; then
                                cecho "Current workspace:" "$CYAN"
                                echo "  $current_workspace"
                            else
                                warn "No workspace set"
                            fi
                        else
                            warn "No workspace set"
                        fi
                    else
                        # Set new workspace
                        local new_workspace="$1"
                        # Resolve to absolute path if it's a directory
                        if [[ -d "$new_workspace" ]]; then
                            new_workspace=$(cd "$new_workspace" && pwd)
                        fi
                        echo "$new_workspace" > "$workspace_file"
                        success "Workspace set to: $new_workspace"
                    fi
                    exit 0
                    ;;
                *)
                    cecho "ClaudeBox Set Commands:" "$CYAN"
                    echo
                    echo -e "  ${GREEN}set workspace [path]${NC}    Set or show workspace directory"
                    echo
                    echo "Examples:"
                    echo "  claudebox set workspace           # Show current workspace"
                    echo "  claudebox set workspace ~         # Set workspace to home"
                    echo "  claudebox set workspace /projects # Set workspace to /projects"
                    echo
                    exit 0
                    ;;
            esac
            ;;
            
        reset)
            shift
            if [[ -z "${1:-}" ]]; then
                error "Please specify a project path or name"
            fi
            
            local project_arg="$1"
            local target_path=""
            
            # Check if it's an absolute path
            if [[ "$project_arg" =~ ^/ ]]; then
                target_path="$project_arg"
            else
                # Try workspace-relative
                local workspace_file="$HOME/.claudebox/workpath"
                if [[ -f "$workspace_file" ]]; then
                    local workspace=$(cat "$workspace_file" 2>/dev/null || echo "")
                    if [[ -n "$workspace" ]]; then
                        target_path="$workspace/$project_arg"
                    fi
                fi
            fi
            
            if [[ -z "$target_path" ]] || [[ ! -d "$target_path" ]]; then
                error "Project not found: $project_arg"
            fi
            
            # Find the parent slot for this project
            local parent_found=false
            for project_dir in "$HOME/.claudebox/projects"/*/ ; do
                [[ -d "$project_dir" ]] || continue
                local config_file="$project_dir/config.ini"
                
                if [[ -f "$config_file" ]]; then
                    local path_value=$(read_config_value "$config_file" "project" "path")
                    if [[ "$path_value" == "$target_path" ]]; then
                        # Check if this is the parent (has iterations file)
                        if [[ -f "$project_dir/.hashcount" ]]; then
                            parent_found=true
                            cecho "Resetting project: $target_path" "$YELLOW"
                            
                            # Touch the config file to trigger rebuild
                            touch "$config_file"
                            
                            # Also remove any cached build hash to force rebuild
                            local project_id=$(basename "$project_dir")
                            local image_name="claudebox-${project_id}"
                            
                            # Remove the image to force rebuild
                            if docker image inspect "$image_name" &>/dev/null; then
                                docker rmi -f "$image_name" 2>/dev/null || true
                                success "✓ Removed Docker image for rebuild"
                            fi
                            
                            success "✓ Project reset - Docker will rebuild on next run"
                            echo
                            echo "All slots for this project will rebuild their Docker images on next launch."
                            break
                        fi
                    fi
                fi
            done
            
            if [[ "$parent_found" != "true" ]]; then
                error "Could not find project configuration for: $target_path"
            fi
            
            exit 0
            ;;

        help)
            show_help
            exit 0
            ;;

        info)
            shift
            # Compute project folder name early for paths
            local project_folder_name
            project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
            IMAGE_NAME="claudebox-${project_folder_name}"
            PROJECT_CLAUDEBOX_DIR="$HOME/.claudebox/projects/$project_folder_name"

            cecho "╔═══════════════════════════════════════════════════════════════════╗" "$CYAN"
            cecho "║                    ClaudeBox Information Panel                    ║" "$CYAN"
            cecho "╚═══════════════════════════════════════════════════════════════════╝" "$CYAN"
            echo

            # Current Project Info
            cecho "📁 Current Project" "$WHITE"
            echo "   Path:       $PROJECT_DIR"
            echo "   Project ID: $project_folder_name"
            echo "   Data Dir:   $PROJECT_CLAUDEBOX_DIR"
            echo

            # ClaudeBox Installation
            cecho "📦 ClaudeBox Installation" "$WHITE"
            echo "   Script:  $SCRIPT_PATH"
            echo "   Symlink: $LINK_TARGET"
            echo

            # Saved CLI Flags
            cecho "🚀 Saved CLI Flags" "$WHITE"
            if [[ -f "$HOME/.claudebox/default-flags" ]]; then
                local saved_flags=()
                while IFS= read -r flag; do
                    [[ -n "$flag" ]] && saved_flags+=("$flag")
                done < "$HOME/.claudebox/default-flags"
                if [[ ${#saved_flags[@]} -gt 0 ]]; then
                    echo -e "   Flags: ${GREEN}${saved_flags[*]}${NC}"
                else
                    echo -e "   ${YELLOW}No flags saved${NC}"
                fi
            else
                echo -e "   ${YELLOW}No saved flags${NC}"
            fi
            echo


            # Claude Commands
            cecho "📝 Claude Commands" "$WHITE"
            local cmd_count=0
            if [[ -d "$HOME/.claudebox/commands" ]]; then
                cmd_count=$(ls -1 "$HOME/.claudebox/commands"/*.md 2>/dev/null | wc -l)
            fi
            local project_cmd_count=0
            if [[ -d ".claude/commands" ]]; then
                project_cmd_count=$(ls -1 .claude/commands/*.md 2>/dev/null | wc -l)
            fi

            if [[ $cmd_count -gt 0 ]] || [[ $project_cmd_count -gt 0 ]]; then
                echo "   Global:  $cmd_count command(s)"
                if [[ $cmd_count -gt 0 ]] && [[ -d "$HOME/.claudebox/commands" ]]; then
                    for cmd_file in "$HOME/.claudebox/commands"/*.md; do
                        [[ -f "$cmd_file" ]] || continue
                        echo "            - $(basename "$cmd_file" .md)"
                    done
                fi
                echo "   Project: $project_cmd_count command(s)"
                if [[ $project_cmd_count -gt 0 ]] && [[ -d ".claude/commands" ]]; then
                    for cmd_file in .claude/commands/*.md; do
                        [[ -f "$cmd_file" ]] || continue
                        echo "            - $(basename "$cmd_file" .md)"
                    done
                fi
            else
                echo -e "   ${YELLOW}No custom commands found${NC}"
                echo -e "   Location: ~/.claudebox/commands/ (global), .claude/commands/ (project)"
            fi
            echo

            # Project Profiles
            cecho "🛠️ Project Profiles& & Packages" "$WHITE"
            local current_profile_file
            current_profile_file=$(get_profile_file_path)
            if [[ -f "$current_profile_file" ]]; then
                local current_profiles=()
                readarray -t current_profiles < <(read_profile_section "$current_profile_file" "profiles")
                local current_packages=()
                readarray -t current_packages < <(read_profile_section "$current_profile_file" "packages")

                if [[ ${#current_profiles[@]} -gt 0 ]]; then
                    echo -e "   Installed:  ${GREEN}${current_profiles[*]}${NC}"
                else
                    echo -e "   Installed:  ${YELLOW}None${NC}"
                fi

                if [[ ${#current_packages[@]} -gt 0 ]]; then
                    echo "   Packages:   ${current_packages[*]}"
                fi
            else
                echo -e "   Status:     ${YELLOW}No profiles installed${NC}"
            fi

            echo -e "   Available:  ${CYAN}core${NC}, python, c, rust, go, javascript, java, ruby, php"
            echo -e "               database, devops, web, ml, security, embedded, networking"
            echo -e "   ${CYAN}Hint:${NC} Run 'claudebox profile' for profile help "
            echo

            cecho "🐳 Docker Status" "$WHITE"
            if docker image inspect "$IMAGE_NAME" &>/dev/null; then
                local image_info=$(docker images --filter "reference=$IMAGE_NAME" --format "{{.Size}}")
                echo -e "   Image:      ${GREEN}Ready${NC} ($IMAGE_NAME - $image_info)"

                local image_created=$(docker inspect "$IMAGE_NAME" --format '{{.Created}}' | cut -d'T' -f1)
                local layer_count=$(docker history "$IMAGE_NAME" --no-trunc --format "{{.CreatedBy}}" | wc -l)
                echo "   Created:    $image_created"
                echo "   Layers:     $layer_count"
            else
                echo -e "   Image:      ${YELLOW}Not built${NC}"
            fi

            local running_containers=$(docker ps --filter "ancestor=$IMAGE_NAME" -q 2>/dev/null)
            if [[ -n "$running_containers" ]]; then
                local container_count=$(echo "$running_containers" | wc -l)
                echo -e "   Containers: ${GREEN}$container_count running${NC}"

                for container_id in $running_containers; do
                    local container_stats="$(docker stats --no-stream --format "{{.Container}}: {{.CPUPerc}} CPU, {{.MemUsage}}" "$container_id" 2>/dev/null || echo "")"
                    if [[ -n "$container_stats" ]]; then
                        echo "               - $container_stats"
                    fi
                done
            else
                echo "   Containers: None running"
            fi
            echo

            # All Projects Summary
            cecho "📊 All Projects Summary" "$WHITE"
            local total_projects=$(ls -1d "$HOME/.claudebox/projects"/*/ 2>/dev/null | wc -l)
            echo "   Projects:   $total_projects total"

            local total_size=$(docker images --filter "reference=claudebox-*" --format "{{.Size}}" | awk '{
                size=$1; unit=$2;
                if (unit == "GB") size = size * 1024;
                else if (unit == "KB") size = size / 1024;
                total += size
            } END {
                if (total > 1024) printf "%.1fGB", total/1024;
                else printf "%.1fMB", total
            }')
            local image_count=$(docker images --filter "reference=claudebox-*" -q | wc -l)
            echo "   Images:     $image_count ClaudeBox images using $total_size"

            local docker_stats=$(docker system df --format "table {{.Type}}\t{{.Total}}\t{{.Active}}\t{{.Size}}\t{{.Reclaimable}}" 2>/dev/null | tail -n +2)
            if [[ -n "$docker_stats" ]]; then
                echo "   System:"
                while IFS=$'\t' read -r type total active size reclaim; do
                    echo "               - $type: $total total, $active active ($size, $reclaim reclaimable)"
                done <<< "$docker_stats"
            fi
            echo

            exit 0
            ;;

    esac
    
    # Check if Docker image is needed and exists (skip if rebuilding)
    case "${1:-}" in
        shell|update|config|mcp|migrate-installer)
            # These commands need Docker image
            if [[ "${CLAUDEBOX_NO_CACHE:-}" != "true" ]] && [[ ! -f /.dockerenv ]] && ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
                error "ClaudeBox image not found.\nRun ${GREEN}claudebox${NC} first to build the image."
            fi
            ;;
    esac
    
    # Now handle Docker-requiring commands
    case "${1:-}" in
        shell)
            # Shell command was already handled above - this line makes case complete
            # The implementation is already in place
            ;;
            
        update|config|mcp|migrate-installer)
            # These commands were already handled above - this line makes case complete
            # The implementation is already in place
            ;;
            
        *)
            # Default case - continue to setup and run claude
            ;;
    esac

    # Ensure shared commands folder is set up
    setup_shared_commands
    
    # Only setup project folder if we're initializing or already initialized
    if [[ "$found_init" == "true" ]] || check_if_initialized "$PROJECT_DIR"; then
        setup_project_folder
        setup_claude_agent_command
    fi

    local need_rebuild=false
    local current_profiles=()
    local profile_hash=""

    local config_file="$PROJECT_CLAUDEBOX_DIR/config.ini"
    if [[ -f "$config_file" ]]; then
        readarray -t current_profiles < <(read_profile_section "$config_file" "profiles")
        local cleaned_profiles=()
        for profile in "${current_profiles[@]}"; do
            profile=$(echo "$profile" | tr -d '[:space:]')
            [[ -z "$profile" ]] && continue
            cleaned_profiles+=("$profile")
        done
        current_profiles=("${cleaned_profiles[@]}")

        if [[ ${#current_profiles[@]} -gt 0 ]]; then
            profile_hash=$(printf '%s\n' "${current_profiles[@]}" | sort | fnv1a_32)
        fi
    fi

    # Calculate hash of the script itself
    local script_hash=$(cat "$SCRIPT_PATH" | fnv1a_32)
    local build_hash="${script_hash}-${profile_hash}"
    
    # Check if build files have changed
    local last_build_hash_file="$HOME/.claudebox/.last_build_hash"
    if [[ -f "$last_build_hash_file" ]]; then
        local last_build_hash=$(cat "$last_build_hash_file")
        if [[ "$build_hash" != "$last_build_hash" ]]; then
            docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
            need_rebuild=true
        fi
    else
        # No hash file means first run or deleted, trigger rebuild
        need_rebuild=true
    fi

    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then

        local image_profile_hash
        image_profile_hash=$(docker inspect "$IMAGE_NAME" --format '{{index .Config.Labels "claudebox.profiles"}}' 2>/dev/null || echo "")

        if [[ "$profile_hash" != "$image_profile_hash" ]]; then
            if [[ ${#current_profiles[@]} -gt 0 ]]; then
                info "Building with profiles: ${current_profiles[*]}"
            fi
            docker rmi -f "$IMAGE_NAME" 2>/dev/null || true
            need_rebuild=true
        fi
    else
        need_rebuild=true
    fi

        if [[ "$need_rebuild" == "true" ]] || ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                logo
                local build_context="$HOME/.claudebox/build"
                mkdir -p "$build_context"
                local dockerfile="$build_context/Dockerfile"

        create_build_files "$build_context"

    info "Using git-delta version: $DELTA_VERSION"

        cat > "$dockerfile" <<'DOCKERFILE'
FROM debian:bookworm
ARG USER_ID GROUP_ID USERNAME NODE_VERSION DELTA_VERSION
ARG REBUILD_TIMESTAMP

RUN echo '#!/bin/sh\nexit 101' > /usr/sbin/policy-rc.d && chmod +x /usr/sbin/policy-rc.d

RUN export DEBIAN_FRONTEND=noninteractive && \
    apt-get update && \
        apt-get install -y --no-autoremove --no-install-recommends ca-certificates curl locales gnupg && apt-get clean && \
    echo "en_US.UTF-8 UTF-8" > /etc/locale.gen && locale-gen en_US.UTF-8 &&\
        mkdir -p /usr/share/keyrings && \
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg -o /tmp/githubcli.gpg && \
        cat /tmp/githubcli.gpg | gpg --dearmor -o /usr/share/keyrings/githubcli-archive-keyring.gpg && \
        rm -f /tmp/githubcli.gpg && \
    chmod 644 /usr/share/keyrings/githubcli-archive-keyring.gpg && \
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg]" \
    "https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null && apt-get update && \
        apt-get install -y --no-autoremove --no-install-recommends apt-utils wget zsh fzf ca-certificates sudo git iptables ipset gh unzip jq \
        procps vim nano less iputils-ping traceroute dnsutils netcat-openbsd net-tools xdg-utils && \
        rm -rf /var/lib/apt/lists/*

ENV LANG=en_US.UTF-8 \
    LANGUAGE=en_US:en \
    LC_ALL=en_US.UTF-8

RUN groupadd -g $GROUP_ID $USERNAME || true && \
    useradd -m -u $USER_ID -g $GROUP_ID -s /bin/bash $USERNAME

RUN ARCH=$(dpkg --print-architecture) && \
    wget -q https://github.com/dandavison/delta/releases/download/${DELTA_VERSION}/git-delta_${DELTA_VERSION}_${ARCH}.deb && \
    dpkg -i git-delta_${DELTA_VERSION}_${ARCH}.deb && \
    rm git-delta_${DELTA_VERSION}_${ARCH}.deb

USER $USERNAME
WORKDIR /home/$USERNAME

RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.2.0/zsh-in-docker.sh)" -- \
    -p git \
    -p fzf \
    -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
    -a "source /usr/share/doc/fzf/examples/completion.zsh" \
    -a 'export HISTFILE="/home/$USERNAME/.cache/zsh_history"' \
    -a 'export HISTSIZE=10000' \
    -a 'export SAVEHIST=10000' \
    -a 'setopt HIST_IGNORE_DUPS' \
    -a 'setopt SHARE_HISTORY' \
    -a 'setopt HIST_FCNTL_LOCK' \
    -a 'setopt APPEND_HISTORY' \
    -a 'export NVM_DIR="$HOME/.nvm"' \
    -a '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' \
    -a '[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"' \
    -x

RUN curl -LsSf https://astral.sh/uv/install.sh | sh

RUN echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc && \
    echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc

RUN git config --global core.pager delta && \
    git config --global interactive.diffFilter "delta --color-only" && \
    git config --global delta.navigate true && \
    git config --global delta.light false && \
    git config --global delta.side-by-side true

ENV DEVCONTAINER=true

ENV SHELL=/bin/zsh

ENV NVM_DIR="/home/$USERNAME/.nvm"
RUN curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

RUN bash -c "source $NVM_DIR/nvm.sh && \
    if [[ \"$NODE_VERSION\" == '--lts' ]]; then \
        nvm install --lts && \
        nvm alias default 'lts/*'; \
    else \
        nvm install $NODE_VERSION && \
        nvm alias default $NODE_VERSION; \
    fi && \
    nvm use default"

RUN echo 'export NVM_DIR="$HOME/.nvm"' >> ~/.bashrc && \
    echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> ~/.bashrc && \
    echo '[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"' >> ~/.bashrc

RUN bash -c "source $NVM_DIR/nvm.sh && \
    nvm use default && \
    npm install -g @anthropic-ai/claude-code"

RUN cat >> ~/.zshrc <<'EOF'

if [[ -n "$PS1" ]] && command -v stty >/dev/null; then
  function _update_size {
    local rows cols
    { stty size } 2>/dev/null | read rows cols
    ((rows)) && export LINES=$rows COLUMNS=$cols
  }
  TRAPWINCH() { _update_size }
  _update_size
fi
EOF

RUN echo "shopt -s checkwinsize" >> ~/.bashrc

RUN cat > ~/.tmux.conf <<'EOF'

set -g aggressive-resize on

set -g default-terminal "screen-256color"
set -ga terminal-overrides ",xterm-256color:Tc"

set -g mouse on
set -g history-limit 10000
EOF

USER root

# Add sudoers entry for claude user (following Anthropic's model)
RUN echo "claude ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/claude && \
    chmod 0440 /etc/sudoers.d/claude

RUN cat > /etc/profile.d/00-winsize.sh <<'EOF'
if [ -n "$PS1" ] && command -v stty >/dev/null 2>&1; then
  _update_size() {
    local sz
    sz=$(stty size 2>/dev/null) || return
    export LINES=${sz%% *}  COLUMNS=${sz##* }
  }
  trap _update_size WINCH
  _update_size
fi
EOF
DOCKERFILE
        if [[ ${#current_profiles[@]} -gt 0 ]]; then
                info "Building with profiles: ${current_profiles[*]}"

                resolved_profiles=()
                for profile in "${current_profiles[@]}"; do
                        resolved_profiles+=($(expand_profile "$profile"))
                done

                unique_profiles=($(awk -v RS=' ' '!seen[$1]++' <<< "${resolved_profiles[*]}"))

                for profile in "${unique_profiles[@]}"; do
                        # Convert space-separated package string to array
                        local packages=$(get_profile_packages "$profile")
                        IFS=' ' read -ra pkg_list <<< "$packages"
                        
                        # Only add apt install section if there are packages
                        if [[ ${#pkg_list[@]} -gt 0 ]]; then
        cat >> "$dockerfile" <<DOCKERFILE
# $(get_profile_description "$profile")
RUN export DEBIAN_FRONTEND=noninteractive && \\
        apt-get update && \\
        apt-get install -y --no-autoremove ${pkg_list[*]} && \\
        apt-get clean && rm -rf /var/lib/apt/lists/*
DOCKERFILE
                        fi
                        
                        # Always check for special installation steps
                        case "$profile" in
                                        rust)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y && \
        echo 'source $HOME/.cargo/env' >> ~/.bashrc && \
        echo 'source $HOME/.cargo/env' >> ~/.zshrc && \
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.bashrc && \
        echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.zshrc
USER root
DOCKERFILE
                                                ;;
                                        go)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
RUN GO_VERSION="1.21.5" && \
        wget -q "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz" && \
        tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz" && \
        rm "go${GO_VERSION}.linux-amd64.tar.gz" && \
        echo 'export PATH=$PATH:/usr/local/go/bin' >> /etc/profile.d/go.sh
DOCKERFILE
                                                ;;
                                        python)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN ~/.local/bin/uv pip install ipython black mypy pylint pytest ruff poetry pipenv
USER root
DOCKERFILE
                                                ;;
                                        ml)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN ~/.local/bin/uv pip install torch transformers scikit-learn numpy pandas matplotlib
USER root
DOCKERFILE
                                                ;;
                                        datascience)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN ~/.local/bin/uv pip install jupyter notebook jupyterlab numpy pandas scipy matplotlib seaborn scikit-learn statsmodels plotly
USER root
DOCKERFILE
                                                ;;
                                        javascript)
                                                cat >> "$dockerfile" <<'DOCKERFILE'
USER $USERNAME
RUN bash -c "source \$NVM_DIR/nvm.sh && npm install -g typescript eslint prettier yarn pnpm"
USER root
DOCKERFILE
                                                ;;
                                        *) : ;;
                                esac
                        done
                fi

        # Add label with profile hash
        echo "# Label the image with the profile hash for change detection" >> "$dockerfile"
        echo "LABEL claudebox.profiles=\"$profile_hash\"" >> "$dockerfile"
        echo "LABEL claudebox.project=\"$project_folder_name\"" >> "$dockerfile"
        echo "" >> "$dockerfile"
        cat >> "$dockerfile" <<'DOCKERFILE'

# Copy init-firewall script
COPY --chmod=755 init-firewall /home/$USERNAME/init-firewall
RUN chown $USERNAME:$USERNAME /home/$USERNAME/init-firewall

USER $USERNAME
RUN bash -c "source $NVM_DIR/nvm.sh && claude --version"

WORKDIR /workspace
USER root
COPY --chown=$USERNAME docker-entrypoint.sh /usr/local/bin/docker-entrypoint
RUN sed -i "s/DOCKERUSER/$USERNAME/g" /usr/local/bin/docker-entrypoint && \
    sed -i "s/DOCKERUSER/$USERNAME/g" /home/$USERNAME/init-firewall && \
    chmod +x /usr/local/bin/docker-entrypoint

ENTRYPOINT ["/usr/local/bin/docker-entrypoint"]
DOCKERFILE

        run_docker_build "$dockerfile" "$build_context"

        # Save build hash for next run
        mkdir -p "$HOME/.claudebox"
        echo "$build_hash" > "$last_build_hash_file"

        # Only show setup complete message if not running init
        if [[ "$found_init" != "true" ]]; then
            echo
            cecho "ClaudeBox Setup Complete!" "$CYAN"
            echo
            cecho "Quick Start:" "$GREEN"
            echo -e "  ${YELLOW}claudebox [options]${NC}        # Launch Claude CLI"
            echo
            cecho "Power Features:" "$GREEN"
            echo -e "  ${YELLOW}claudebox profiles${NC}               # See all available profiles"
            echo -e "  ${YELLOW}claudebox profile c openwrt${NC}      # Install C + OpenWRT tools"
            echo -e "  ${YELLOW}claudebox profile python ml${NC}      # Install Python + ML stack"
            echo -e "  ${YELLOW}claudebox install <packages>${NC}     # Install additional apt packages"
            echo -e "  ${YELLOW}claudebox shell${NC}                  # Open powerline shell in container"
            echo -e "  ${YELLOW}claudebox allowlist${NC}              # View firewall configuration"
            echo
            cecho "Security:" "$GREEN"
            echo -e "  Network firewall: ON by default (Anthropic recommended)"
            echo -e "  Sudo access: OFF by default"
            echo
            cecho "Maintenance:" "$GREEN"
            echo -e "  ${YELLOW}claudebox clean ${NC}                 # See all cleanup options"
            echo -e "  ${YELLOW}claudebox unlink ${NC}                # Remove symbolic link"
            echo
            cecho "Just install the profile you need and start coding!" "$PURPLE"
            exit 0
        fi
   fi

   # Run container

   # Ensure .claudebox exists with proper permissions
   if [[ ! -d "$HOME/.claudebox" ]]; then
       mkdir -p "$HOME/.claudebox"
   fi

   # Fix permissions if needed
   if [[ ! -w "$HOME/.claudebox" ]]; then
       warn "Fixing .claudebox permissions..."
       sudo chown -R "$USER:$USER" "$HOME/.claudebox" || true
   fi

   # Create default allowlist file if it doesn't exist
   local allowlist_file="$PROJECT_CLAUDEBOX_DIR/allowlist"
   
   if [[ ! -f "$allowlist_file" ]]; then
       # Create allowlist with default domains
       cat > "$allowlist_file" <<'EOF'
# Default domains (always allowed):
# api.anthropic.com, console.anthropic.com, statsig.anthropic.com, sentry.io

# GitHub.com
github.com
api.github.com
raw.githubusercontent.com
ssh.github.com
avatars.githubusercontent.com
codeload.github.com
objects.githubusercontent.com
pipelines.actions.githubusercontent.com
ghcr.io
pkg-containers.githubusercontent.com

# GitLab.com
gitlab.com
api.gitlab.com
registry.gitlab.com
uploads.gitlab.com
gitlab.io
*.gitlab.io
*.s3.amazonaws.com
*.amazonaws.com

# Bitbucket.org
bitbucket.org
api.bitbucket.org
altssh.bitbucket.org
bbuseruploads.s3.amazonaws.com
bitbucket-pipelines-prod-us-west-2.s3.amazonaws.com
bitbucket-pipelines-prod-us-east-1.s3.amazonaws.com
bitbucket-pipelines-prod-eu-west-1.s3.amazonaws.com

# Atlassian IP Ranges (Bitbucket Cloud)
104.192.136.0/21
185.166.140.0/22
13.200.41.128/25
18.246.31.128/25

# Optional (Git LFS, Assets)
github-cloud.s3.amazonaws.com
github-releases.githubusercontent.com
github-production-release-asset-2e65be.s3.amazonaws.com
EOF
   fi

   set -- "${DEFAULT_FLAGS[@]}" "$@"

   # Flag Prioritizer System
   # Define control flags and their priority (lower number = higher priority)
   # Using function for Bash 3.2 compatibility
   get_control_flag_priority() {
       case "$1" in
           "--shell-mode") echo 1 ;;
           "--enable-sudo") echo 2 ;;
           "--disable-firewall") echo 3 ;;
           *) echo "" ;;
       esac
   }
   
   # Check if .claude/projects exists, if not remove -c flag
   if [[ ! -d "$PROJECT_CLAUDEBOX_DIR/.claude/projects" ]]; then
       local filtered_args=()
       for arg in "$@"; do
           if [[ "$arg" != "-c" && "$arg" != "--continue" ]]; then
               filtered_args+=("$arg")
           fi
       done
       set -- "${filtered_args[@]}"
   fi
   
   # Extract and sort control flags
   local control_flags=()
   local claude_flags=()
   local temp_args=("$@")
   
   # Extract control flags and separate from Claude flags
   for arg in "${temp_args[@]}"; do
       local priority=$(get_control_flag_priority "$arg")
       if [[ -n "$priority" ]]; then
           control_flags+=("$arg")
       else
           claude_flags+=("$arg")
       fi
   done
   
   # Sort control flags by priority
   if [[ ${#control_flags[@]} -gt 0 ]]; then
       IFS=$'\n' control_flags=($(
           for flag in "${control_flags[@]}"; do
               echo "$(get_control_flag_priority "$flag"):$flag"
           done | sort -n | cut -d: -f2
       ))
   fi
   

   # Handle update command specially to persist changes
   if [[ "${claude_flags[0]:-}" == "update" ]]; then
       local project_folder_name
       project_folder_name=$(get_project_folder_name "$PROJECT_DIR")
       local temp_container="claudebox-update-${project_folder_name}-$$"
       
       # Run update in a named container and capture output
       local update_output
       update_output=$(run_claudebox_container "$temp_container" "attached" ${control_flags[@]+"${control_flags[@]}"} ${claude_flags[@]+"${claude_flags[@]}"} 2>&1)
       echo "$update_output"
       
       # Only commit if an actual update occurred
       if echo "$update_output" | grep -q "Successfully updated\|Verifying update"; then
           fillbar
           docker commit "$temp_container" "$IMAGE_NAME" >/dev/null
           fillbar stop
           success "Claude updated and changes saved to image!"
       fi
       
       # Always remove the container
       docker rm -f "$temp_container" >/dev/null 2>&1
   else
       # For now, just run the container directly without persistence
       # This approach is simpler and more reliable
       run_claudebox_container "" "interactive" ${control_flags[@]+"${control_flags[@]}"} ${claude_flags[@]+"${claude_flags[@]}"}
   fi
}

main "$@"
